// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.20.0
// source: server_farm.job.proto

package server_farm_job

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	JobService_Describe_FullMethodName           = "/InternalApi.ServerFarm.Job.JobService/Describe"
	JobService_List_FullMethodName               = "/InternalApi.ServerFarm.Job.JobService/List"
	JobService_ListDebugSessions_FullMethodName  = "/InternalApi.ServerFarm.Job.JobService/ListDebugSessions"
	JobService_Count_FullMethodName              = "/InternalApi.ServerFarm.Job.JobService/Count"
	JobService_CountByState_FullMethodName       = "/InternalApi.ServerFarm.Job.JobService/CountByState"
	JobService_Stop_FullMethodName               = "/InternalApi.ServerFarm.Job.JobService/Stop"
	JobService_TotalExecutionTime_FullMethodName = "/InternalApi.ServerFarm.Job.JobService/TotalExecutionTime"
	JobService_GetAgentPayload_FullMethodName    = "/InternalApi.ServerFarm.Job.JobService/GetAgentPayload"
	JobService_CanDebug_FullMethodName           = "/InternalApi.ServerFarm.Job.JobService/CanDebug"
	JobService_CanAttach_FullMethodName          = "/InternalApi.ServerFarm.Job.JobService/CanAttach"
	JobService_Create_FullMethodName             = "/InternalApi.ServerFarm.Job.JobService/Create"
)

// JobServiceClient is the client API for JobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobServiceClient interface {
	// Operation is called to describe an existing job.
	// Operation is synchronous.
	Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error)
	// Operation is called to list jobs.
	// Operation is synchronous.
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// Operation is called to list debug sessions.
	// Operation is synchronous.
	ListDebugSessions(ctx context.Context, in *ListDebugSessionsRequest, opts ...grpc.CallOption) (*ListDebugSessionsResponse, error)
	// Operation is called to count jobs.
	// Operation is synchronous.
	Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error)
	// Operation is called to count jobs by state
	// Operation is synchronous
	CountByState(ctx context.Context, in *CountByStateRequest, opts ...grpc.CallOption) (*CountByStateResponse, error)
	// Operation is called to stop previously scheduled job.
	// Operation is synchronous and idempotent.
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// Get total usage in seconds for any particular organizations.
	// Where Total Execution Time = sum(duration of all finished jobs) + sum(duration of all running jobs)
	//
	// Primary use case is to check suspicious activity on newly created organizations.
	// For example, bitcoin mining.
	TotalExecutionTime(ctx context.Context, in *TotalExecutionTimeRequest, opts ...grpc.CallOption) (*TotalExecutionTimeResponse, error)
	// Returns the JSON payload that is given to an Agent to execute a job.
	// The JSON payload contains all information necessary to run a job on an Agent.
	//
	// This call was introduced to support self-hosted agents.
	// For hosted jobs, zebra is sending this payload with HTTP POST directly to
	// the agent. For self-hosted ones, the agent will fetch this payload from
	// Semaphore via HTTP GET.
	GetAgentPayload(ctx context.Context, in *GetAgentPayloadRequest, opts ...grpc.CallOption) (*GetAgentPayloadResponse, error)
	// Returns information if a user can debug a job.
	CanDebug(ctx context.Context, in *CanDebugRequest, opts ...grpc.CallOption) (*CanDebugResponse, error)
	// Returns information if a user can attach a job.
	CanAttach(ctx context.Context, in *CanAttachRequest, opts ...grpc.CallOption) (*CanAttachResponse, error)
	// Create a new job based on the given job spec.
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
}

type jobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobServiceClient(cc grpc.ClientConnInterface) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error) {
	out := new(DescribeResponse)
	err := c.cc.Invoke(ctx, JobService_Describe_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, JobService_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) ListDebugSessions(ctx context.Context, in *ListDebugSessionsRequest, opts ...grpc.CallOption) (*ListDebugSessionsResponse, error) {
	out := new(ListDebugSessionsResponse)
	err := c.cc.Invoke(ctx, JobService_ListDebugSessions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error) {
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, JobService_Count_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) CountByState(ctx context.Context, in *CountByStateRequest, opts ...grpc.CallOption) (*CountByStateResponse, error) {
	out := new(CountByStateResponse)
	err := c.cc.Invoke(ctx, JobService_CountByState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, JobService_Stop_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) TotalExecutionTime(ctx context.Context, in *TotalExecutionTimeRequest, opts ...grpc.CallOption) (*TotalExecutionTimeResponse, error) {
	out := new(TotalExecutionTimeResponse)
	err := c.cc.Invoke(ctx, JobService_TotalExecutionTime_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetAgentPayload(ctx context.Context, in *GetAgentPayloadRequest, opts ...grpc.CallOption) (*GetAgentPayloadResponse, error) {
	out := new(GetAgentPayloadResponse)
	err := c.cc.Invoke(ctx, JobService_GetAgentPayload_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) CanDebug(ctx context.Context, in *CanDebugRequest, opts ...grpc.CallOption) (*CanDebugResponse, error) {
	out := new(CanDebugResponse)
	err := c.cc.Invoke(ctx, JobService_CanDebug_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) CanAttach(ctx context.Context, in *CanAttachRequest, opts ...grpc.CallOption) (*CanAttachResponse, error) {
	out := new(CanAttachResponse)
	err := c.cc.Invoke(ctx, JobService_CanAttach_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, JobService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobServiceServer is the server API for JobService service.
// All implementations should embed UnimplementedJobServiceServer
// for forward compatibility
type JobServiceServer interface {
	// Operation is called to describe an existing job.
	// Operation is synchronous.
	Describe(context.Context, *DescribeRequest) (*DescribeResponse, error)
	// Operation is called to list jobs.
	// Operation is synchronous.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Operation is called to list debug sessions.
	// Operation is synchronous.
	ListDebugSessions(context.Context, *ListDebugSessionsRequest) (*ListDebugSessionsResponse, error)
	// Operation is called to count jobs.
	// Operation is synchronous.
	Count(context.Context, *CountRequest) (*CountResponse, error)
	// Operation is called to count jobs by state
	// Operation is synchronous
	CountByState(context.Context, *CountByStateRequest) (*CountByStateResponse, error)
	// Operation is called to stop previously scheduled job.
	// Operation is synchronous and idempotent.
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	// Get total usage in seconds for any particular organizations.
	// Where Total Execution Time = sum(duration of all finished jobs) + sum(duration of all running jobs)
	//
	// Primary use case is to check suspicious activity on newly created organizations.
	// For example, bitcoin mining.
	TotalExecutionTime(context.Context, *TotalExecutionTimeRequest) (*TotalExecutionTimeResponse, error)
	// Returns the JSON payload that is given to an Agent to execute a job.
	// The JSON payload contains all information necessary to run a job on an Agent.
	//
	// This call was introduced to support self-hosted agents.
	// For hosted jobs, zebra is sending this payload with HTTP POST directly to
	// the agent. For self-hosted ones, the agent will fetch this payload from
	// Semaphore via HTTP GET.
	GetAgentPayload(context.Context, *GetAgentPayloadRequest) (*GetAgentPayloadResponse, error)
	// Returns information if a user can debug a job.
	CanDebug(context.Context, *CanDebugRequest) (*CanDebugResponse, error)
	// Returns information if a user can attach a job.
	CanAttach(context.Context, *CanAttachRequest) (*CanAttachResponse, error)
	// Create a new job based on the given job spec.
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
}

// UnimplementedJobServiceServer should be embedded to have forward compatible implementations.
type UnimplementedJobServiceServer struct {
}

func (UnimplementedJobServiceServer) Describe(context.Context, *DescribeRequest) (*DescribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Describe not implemented")
}
func (UnimplementedJobServiceServer) List(context.Context, *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedJobServiceServer) ListDebugSessions(context.Context, *ListDebugSessionsRequest) (*ListDebugSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDebugSessions not implemented")
}
func (UnimplementedJobServiceServer) Count(context.Context, *CountRequest) (*CountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Count not implemented")
}
func (UnimplementedJobServiceServer) CountByState(context.Context, *CountByStateRequest) (*CountByStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountByState not implemented")
}
func (UnimplementedJobServiceServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedJobServiceServer) TotalExecutionTime(context.Context, *TotalExecutionTimeRequest) (*TotalExecutionTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TotalExecutionTime not implemented")
}
func (UnimplementedJobServiceServer) GetAgentPayload(context.Context, *GetAgentPayloadRequest) (*GetAgentPayloadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentPayload not implemented")
}
func (UnimplementedJobServiceServer) CanDebug(context.Context, *CanDebugRequest) (*CanDebugResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanDebug not implemented")
}
func (UnimplementedJobServiceServer) CanAttach(context.Context, *CanAttachRequest) (*CanAttachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanAttach not implemented")
}
func (UnimplementedJobServiceServer) Create(context.Context, *CreateRequest) (*CreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}

// UnsafeJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServiceServer will
// result in compilation errors.
type UnsafeJobServiceServer interface {
	mustEmbedUnimplementedJobServiceServer()
}

func RegisterJobServiceServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	s.RegisterService(&JobService_ServiceDesc, srv)
}

func _JobService_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_Describe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).Describe(ctx, req.(*DescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_ListDebugSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDebugSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).ListDebugSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_ListDebugSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).ListDebugSessions(ctx, req.(*ListDebugSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_Count_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).Count(ctx, req.(*CountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_CountByState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountByStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).CountByState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_CountByState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).CountByState(ctx, req.(*CountByStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_TotalExecutionTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TotalExecutionTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).TotalExecutionTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_TotalExecutionTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).TotalExecutionTime(ctx, req.(*TotalExecutionTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetAgentPayload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentPayloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetAgentPayload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetAgentPayload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetAgentPayload(ctx, req.(*GetAgentPayloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_CanDebug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanDebugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).CanDebug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_CanDebug_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).CanDebug(ctx, req.(*CanDebugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_CanAttach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanAttachRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).CanAttach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_CanAttach_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).CanAttach(ctx, req.(*CanAttachRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JobService_ServiceDesc is the grpc.ServiceDesc for JobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "InternalApi.ServerFarm.Job.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Describe",
			Handler:    _JobService_Describe_Handler,
		},
		{
			MethodName: "List",
			Handler:    _JobService_List_Handler,
		},
		{
			MethodName: "ListDebugSessions",
			Handler:    _JobService_ListDebugSessions_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _JobService_Count_Handler,
		},
		{
			MethodName: "CountByState",
			Handler:    _JobService_CountByState_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _JobService_Stop_Handler,
		},
		{
			MethodName: "TotalExecutionTime",
			Handler:    _JobService_TotalExecutionTime_Handler,
		},
		{
			MethodName: "GetAgentPayload",
			Handler:    _JobService_GetAgentPayload_Handler,
		},
		{
			MethodName: "CanDebug",
			Handler:    _JobService_CanDebug_Handler,
		},
		{
			MethodName: "CanAttach",
			Handler:    _JobService_CanAttach_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _JobService_Create_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server_farm.job.proto",
}
