<?xml version="1.0"?><testsuites><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.Scheduler.SelectorTest" tests="28" time="0.2422"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/scheduler/selector_test.exs:371" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test organization Quota cold load - failures on feature service" time="0.0087"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:408" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test organization Quota getting max_running_jobs quota" time="0.0173"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:154" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select combined running jobs and max_running_jobs" time="0.0148"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:301" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test selection State getting currently known running jobs with machine type count" time="0.0078"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:364" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test organization Quota cold load" time="0.0050"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:295" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test selection State getting currently known running jobs count" time="0.0101"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:186" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select scheduling every type of machine" time="0.0115"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:170" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select combined running jobs and machine quota" time="0.0090"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:308" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test selection State recording a job as running" time="0.0086"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:394" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test organization Quota failures are not cached" time="0.0059"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:327" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test selection Result initialization" time="0.0044"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:92" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select selects jobs upto the max_parallel_job limit" time="0.0073"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:428" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test organization Quota getting machine_quota for unknown machine type" time="0.0050"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:227" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select when jobs have same priority => the older ones are selected first " time="0.0081"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:35" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select when the max_job_quota is 0 => it returns all jobs for force finish" time="0.0072"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:347" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test selection Result adding a job for force finish" time="0.0043"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:142" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select unknown machine types immidiately fail" time="0.0121"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:68" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select when the organization is suspended => it returns all jobs for force finish" time="0.0072"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:287" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test selection State loading state from DB" time="0.0080"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:417" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test organization Quota getting machine_quota for known machine type" time="0.0042"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:107" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select selects jobs upto the machine type limits" time="0.0081"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:210" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select when there are jobs with different priorities => higher priority jobs are selected" time="0.0080"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:47" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select when the organization is running jobs on unknown machine type => force finish the job" time="0.0069"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:121" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select combined max_limit and machine limits" time="0.0101"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:379" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test organization Quota hot load" time="0.0048"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:334" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test selection Result adding a job for scheduling" time="0.0043"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:245" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select jobs that have no priority set are selected last" time="0.0101"/><testcase file="test/zebra/workers/scheduler/selector_test.exs:80" classname="Elixir.Zebra.Workers.Scheduler.SelectorTest" name="test .select when a job has machine type quota of 0 => it sets it for force finish" time="0.0234"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Grpc.HealthCheck.Test" tests="3" time="0.0051"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/health_check_server_test.exs:8" classname="Elixir.Zebra.Grpc.HealthCheck.Test" name="test no workers are required => SERVING" time="0.0005"/><testcase file="test/zebra/health_check_server_test.exs:44" classname="Elixir.Zebra.Grpc.HealthCheck.Test" name="test worker required and started check => SERVING" time="0.0009"/><testcase file="test/zebra/health_check_server_test.exs:20" classname="Elixir.Zebra.Grpc.HealthCheck.Test" name="test worker required but not started check => NOT_SERVING" time="0.0037"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" tests="14" time="0.0726"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:653" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? try attach when secret can debug but can't attach => false" time="0.0045"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:701" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? try debug when secret can debug but can't attach => true" time="0.0043"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:294" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .load when there are several requested secrets => fetches them from API" time="0.0047"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:637" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? when some secrets are not available to load" time="0.0054"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:229" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .load good checkout metadata" time="0.0038"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:389" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .load when some secrets are filtered out" time="0.0047"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:685" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? try debug when secret can't debug but can attach => false" time="0.0045"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:511" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .load when all secrets are filtered out" time="0.0039"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:733" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? when all secrets are ok" time="0.0044"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:609" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? when there are no secrets used in job => returns true" time="0.0040"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:195" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .load when there are no requested secrets => returns empty result" time="0.0043"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:717" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? when not org-secret => true" time="0.0053"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:669" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .can_use_secret? try attach when secret can't debug but can attach => true" time="0.0080"/><testcase file="test/zebra/workers/job_request_factory/secrets_test.exs:574" classname="Elixir.Zebra.Workers.JobRequestFactory.SecretsTest" name="test .load when secrets are not found" time="0.0107"/></testsuite><testsuite errors="0" failures="12" skipped="0" name="Elixir.Zebra.MonitorTest" tests="13" time="0.1077"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/monitor_test.exs:317" classname="Elixir.Zebra.MonitorTest" name="test count_scheduled_jobs" time="0.0112"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  1) test count_scheduled_jobs (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:317
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_scheduled_jobs() == {
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       (zebra 0.0.1) lib/zebra/monitor.ex:46: Zebra.Monitor.count_scheduled_jobs/0
       test/zebra/monitor_test.exs:326: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:360" classname="Elixir.Zebra.MonitorTest" name="test count_running_tasks" time="0.0048"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  2) test count_running_tasks (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:360
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_running_tasks() == 1
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:191: Zebra.Monitor.count_running_tasks/0
       test/zebra/monitor_test.exs:363: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:17" classname="Elixir.Zebra.MonitorTest" name="test .stop_jobs_on_suspended_orgs doesn't stop job for non-suspended orgs" time="0.0065"/><testcase file="test/zebra/monitor_test.exs:311" classname="Elixir.Zebra.MonitorTest" name="test count_enqueued_jobs" time="0.0055"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  4) test count_enqueued_jobs (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:311
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_enqueued_jobs() == 1
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:31: Zebra.Monitor.count_enqueued_jobs/0
       test/zebra/monitor_test.exs:314: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:7" classname="Elixir.Zebra.MonitorTest" name="test .stop_jobs_on_suspended_orgs stop job for suspended orgs" time="0.0129"><failure message="match (=) failed">  5) test .stop_jobs_on_suspended_orgs stop job for suspended orgs (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:7
     match (=) failed
     code:  assert {:ok, _} = Zebra.Models.JobStopRequest.find_by_job_id(job.id)
     left:  {:ok, _}
     right: {:error, :not_found}
     stacktrace:
       test/zebra/monitor_test.exs:14: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:110" classname="Elixir.Zebra.MonitorTest" name="test count_stuck_jobs when the jobs don't have an execution_time_limit" time="0.0068"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  6) test count_stuck_jobs when the jobs don't have an execution_time_limit (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:110
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_stuck_jobs() == 1
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:169: Zebra.Monitor.count_stuck_jobs/0
       test/zebra/monitor_test.exs:134: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:352" classname="Elixir.Zebra.MonitorTest" name="test count_started_jobs" time="0.0069"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  7) test count_started_jobs (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:352
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_started_jobs() == {2, 1}
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:149: Zebra.Monitor.count_started_jobs/0
       test/zebra/monitor_test.exs:357: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:137" classname="Elixir.Zebra.MonitorTest" name="test count_stuck_jobs when the jobs have an execution_time_limit" time="0.0071"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  8) test count_stuck_jobs when the jobs have an execution_time_limit (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:137
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_stuck_jobs() == 2
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:169: Zebra.Monitor.count_stuck_jobs/0
       test/zebra/monitor_test.exs:164: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:370" classname="Elixir.Zebra.MonitorTest" name="test count_inconsistent_jobs" time="0.0148"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  9) test count_inconsistent_jobs (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:370
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_inconsistent_jobs() == 1
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:181: Zebra.Monitor.count_inconsistent_jobs/0
       test/zebra/monitor_test.exs:376: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:305" classname="Elixir.Zebra.MonitorTest" name="test count_pending_jobs" time="0.0063"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 10) test count_pending_jobs (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:305
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_pending_jobs() == 1
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:19: Zebra.Monitor.count_pending_jobs/0
       test/zebra/monitor_test.exs:308: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:366" classname="Elixir.Zebra.MonitorTest" name="test count_pending_job_stop_requests" time="0.0044"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 11) test count_pending_job_stop_requests (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:366
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_pending_job_stop_requests() == 0
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:201: Zebra.Monitor.count_pending_job_stop_requests/0
       test/zebra/monitor_test.exs:367: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:345" classname="Elixir.Zebra.MonitorTest" name="test count_waiting_for_agent_jobs" time="0.0063"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 12) test count_waiting_for_agent_jobs (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:345
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.count_waiting_for_agent_jobs() == 2
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/monitor.ex:69: Zebra.Monitor.count_waiting_for_agent_jobs/0
       test/zebra/monitor_test.exs:349: (test)
</failure></testcase><testcase file="test/zebra/monitor_test.exs:168" classname="Elixir.Zebra.MonitorTest" name="test measure waiting times" time="0.0143"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 13) test measure waiting times (Zebra.MonitorTest)
     test/zebra/monitor_test.exs:168
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert Monitor.waiting_times() == %{
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (elixir 1.13.4) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (stdlib 3.17.2.4) maps.erl:410: :maps.fold_1/3
       (elixir 1.13.4) lib/enum.ex:2408: Enum.each/2
       (elixir 1.13.4) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (stdlib 3.17.2.4) maps.erl:410: :maps.fold_1/3
       (elixir 1.13.4) lib/enum.ex:2408: Enum.each/2
       (zebra 0.0.1) lib/zebra/monitor.ex:84: Zebra.Monitor.waiting_times/0
       test/zebra/monitor_test.exs:175: (test)
</failure></testcase></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Machines.BrownoutScheduleTest" tests="2" time="0.0001"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/machines/brownout_schedule_test.exs:29" classname="Elixir.Zebra.Machines.BrownoutScheduleTest" name="test creating phases work as expected" time="0.0000"/><testcase file="test/zebra/machines/brownout_schedule_test.exs:6" classname="Elixir.Zebra.Machines.BrownoutScheduleTest" name="test creates macos-xcode14 brownout schedule" time="0.0001"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" tests="21" time="0.0791"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:505" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test env_var no options are passed => encodes the value to base64" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:529" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test file when 'encode_to_base64: false' => does not encode the content" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:11" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitized?/1 sanitized => false" time="0.0036"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:292" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitize all files" time="0.0034"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:498" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test env_var value is nil => encodes using empty string" time="0.0036"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:220" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitizes some SEMAPHORE_* environment variables (old request)" time="0.0040"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:87" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 nil => nil" time="0.0034"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:47" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitized?/1 sanitized => true" time="0.0034"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:310" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitize all files (old request)" time="0.0038"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:521" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test file no options are passed => encodes the content to base64" time="0.0038"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:366" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitize compose" time="0.0036"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:747" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test redirect_semaphoreci_convenient_images" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:111" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitizes all non SEMAPHORE_* environment variables (old request)" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:466" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitizes callback token" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:7" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitized?/1 nil => true" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:194" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitizes some SEMAPHORE_* environment variables" time="0.0040"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:538" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test the format of the payload is suitable for agents" time="0.0048"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:91" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitizes all non SEMAPHORE_* environment variables" time="0.0039"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:512" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test env_var when 'encode_to_base64: false' => does not value the content" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:438" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitize only push logger" time="0.0039"/><testcase file="test/zebra/workers/job_request_factory/job_request_test.exs:163" classname="Elixir.Zebra.Workers.JobRequestFactory.JobRequestTest" name="test .sanitize/1 sanitizing already sanitized request produces same result" time="0.0039"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Api.InternalJobApi.TotalExecutionTimeTest" tests="4" time="0.0241"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/internal_job_api/total_execution_time_test.exs:18" classname="Elixir.Zebra.Api.InternalJobApi.TotalExecutionTimeTest" name="test calculates both running and finished jobs" time="0.0058"/><testcase file="test/zebra/apis/internal_job_api/total_execution_time_test.exs:12" classname="Elixir.Zebra.Api.InternalJobApi.TotalExecutionTimeTest" name="test it returns 0 if there are no jobs" time="0.0045"/><testcase file="test/zebra/apis/internal_job_api/total_execution_time_test.exs:44" classname="Elixir.Zebra.Api.InternalJobApi.TotalExecutionTimeTest" name="test it calculates only for one org" time="0.0074"/><testcase file="test/zebra/apis/internal_job_api/total_execution_time_test.exs:30" classname="Elixir.Zebra.Api.InternalJobApi.TotalExecutionTimeTest" name="test it calculates only for the last 24hours" time="0.0065"/></testsuite><testsuite errors="0" failures="12" skipped="0" name="Elixir.Zebra.Workers.DispatcherTest" tests="12" time="0.3393"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/dispatcher_test.exs:367" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .process processes the job with given id => when the job is scheduled" time="0.0000"><failure message="{:EXIT, #PID&lt;0.3443.0>}: {:badarg, [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}">  1) test .process processes the job with given id =&gt; when the job is scheduled (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:367
     ** (EXIT from #PID&lt;0.3443.0&gt;) an exception was raised:
         ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
             :erlang.process_info(nil, :message_queue_len)
             (elixir 1.13.4) lib/process.ex:773: Process.info/2
             (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
             (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
             (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
             (elixir 1.13.4) lib/task/supervised.ex:89: Task.Supervised.invoke_mfa/2
             (elixir 1.13.4) lib/task/supervised.ex:34: Task.Supervised.reply/4
             (stdlib 3.17.2.4) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:450" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .process when self-hosted job and agent information is received => job starts" time="0.0283"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  2) test .process when self-hosted job and agent information is received =&gt; job starts (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:450
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
       (zebra 0.0.1) lib/zebra/workers/dispatcher.ex:85: Zebra.Workers.Dispatcher.dispatch_self_hosted_job/1
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:460: (test)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:12" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .tick processes only cloud scheduled jobs" time="0.0317"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  3) test .tick processes only cloud scheduled jobs (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:12
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/db_worker.ex:58: Zebra.Workers.DbWorker.tick_/2
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:42: (test)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:327" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .tick dispatches self-hosted jobs when os_image is blank or nil" time="0.0327"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  4) test .tick dispatches self-hosted jobs when os_image is blank or nil (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:327
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/db_worker.ex:58: Zebra.Workers.DbWorker.tick_/2
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:350: (test)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:63" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .tick processes only self-hosted scheduled jobs" time="0.0362"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  5) test .tick processes only self-hosted scheduled jobs (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:63
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/db_worker.ex:58: Zebra.Workers.DbWorker.tick_/2
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:88: (test)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:421" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .process skips the processing => when the agent is broken" time="0.0000"><failure message="{:EXIT, #PID&lt;0.3389.0>}: {:badarg, [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}">  6) test .process skips the processing =&gt; when the agent is broken (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:421
     ** (EXIT from #PID&lt;0.3389.0&gt;) an exception was raised:
         ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
             :erlang.process_info(nil, :message_queue_len)
             (elixir 1.13.4) lib/process.ex:773: Process.info/2
             (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
             (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
             (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
             (elixir 1.13.4) lib/task/supervised.ex:89: Task.Supervised.invoke_mfa/2
             (elixir 1.13.4) lib/task/supervised.ex:34: Task.Supervised.reply/4
             (stdlib 3.17.2.4) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:107" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .tick processes all scheduled jobs" time="0.0376"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  7) test .tick processes all scheduled jobs (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:107
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/db_worker.ex:58: Zebra.Workers.DbWorker.tick_/2
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:144: (test)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:490" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .process submits correct metrics" time="0.0000"><failure message="{:EXIT, #PID&lt;0.3364.0>}: {:badarg, [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman_meck_original, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}, {Watchman, :benchmark, [&quot;zebra.external.chmura.occupy&quot;, #Function&lt;3.105749010/0 in Zebra.Workers.Agent.HostedAgent.occupy/1>], []}]}">  8) test .process submits correct metrics (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:490
     ** (EXIT from #PID&lt;0.3364.0&gt;) an exception was raised:
         ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
             :erlang.process_info(nil, :message_queue_len)
             (elixir 1.13.4) lib/process.ex:773: Process.info/2
             (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
             (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
             lib/watchman.ex:37: Watchman_meck_original.benchmark/2
             (elixir 1.13.4) lib/task/supervised.ex:89: Task.Supervised.invoke_mfa/2
             (elixir 1.13.4) lib/task/supervised.ex:34: Task.Supervised.reply/4
             (stdlib 3.17.2.4) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
             (watchman 0.2.0) Watchman.benchmark("zebra.external.chmura.occupy", #Function&lt;3.105749010/0 in Zebra.Workers.Agent.HostedAgent.occupy/1&gt;)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:235" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .tick isolates dispatching by both machine_type and os_image" time="0.0579"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  9) test .tick isolates dispatching by both machine_type and os_image (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:235
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/db_worker.ex:58: Zebra.Workers.DbWorker.tick_/2
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:300: (test)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:470" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .process when self-hosted job and no agent information is received => job waits" time="0.0295"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 10) test .process when self-hosted job and no agent information is received =&gt; job waits (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:470
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
       (zebra 0.0.1) lib/zebra/workers/dispatcher.ex:85: Zebra.Workers.Dispatcher.dispatch_self_hosted_job/1
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:480: (test)
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:395" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .process skips the processing => when the job is not scheduled" time="0.0000"><failure message="{:EXIT, #PID&lt;0.3327.0>}: {:badarg, [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}"> 11) test .process skips the processing =&gt; when the job is not scheduled (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:395
     ** (EXIT from #PID&lt;0.3327.0&gt;) an exception was raised:
         ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
             :erlang.process_info(nil, :message_queue_len)
             (elixir 1.13.4) lib/process.ex:773: Process.info/2
             (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
             (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
             (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
             (elixir 1.13.4) lib/task/supervised.ex:89: Task.Supervised.invoke_mfa/2
             (elixir 1.13.4) lib/task/supervised.ex:34: Task.Supervised.reply/4
             (stdlib 3.17.2.4) proc_lib.erl:226: :proc_lib.init_p_do_apply/3
</failure></testcase><testcase file="test/zebra/workers/dispatcher_test.exs:163" classname="Elixir.Zebra.Workers.DispatcherTest" name="test .tick processes all jobs with readily available agents" time="0.0855"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 12) test .tick processes all jobs with readily available agents (Zebra.Workers.DispatcherTest)
     test/zebra/workers/dispatcher_test.exs:163
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: with_stubbed_http_calls(fn -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/db_worker.ex:58: Zebra.Workers.DbWorker.tick_/2
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       test/zebra/workers/dispatcher_test.exs:2: Zebra.Workers.DispatcherTest.with_stubbed_http_calls/2
       test/zebra/workers/dispatcher_test.exs:212: (test)
</failure></testcase></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobTeardownCallbackWorkerTest" tests="3" time="0.0235"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_teardown_callback_worker_test.exs:8" classname="Elixir.Zebra.Workers.JobTeardownCallbackWorkerTest" name="test .handle_message when the job is present in the db => tries to release agent" time="0.0066"/><testcase file="test/zebra/workers/job_teardown_callback_worker_test.exs:32" classname="Elixir.Zebra.Workers.JobTeardownCallbackWorkerTest" name="test .handle_message when the container is not present in the DB => does nothing" time="0.0048"/><testcase file="test/zebra/workers/job_teardown_callback_worker_test.exs:20" classname="Elixir.Zebra.Workers.JobTeardownCallbackWorkerTest" name="test .handle_message when the job is present in the db => tries to release agent => fails" time="0.0120"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Models.TaskTest" tests="9" time="1.0577"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/models/task_test.exs:43" classname="Elixir.Zebra.Models.TaskTest" name="test .finish it sets the result" time="0.0047"/><testcase file="test/zebra/models/task_test.exs:86" classname="Elixir.Zebra.Models.TaskTest" name="test .find_by_id_or_request_token when the task can be found by request token" time="0.0047"/><testcase file="test/zebra/models/task_test.exs:32" classname="Elixir.Zebra.Models.TaskTest" name="test .update it updates the fields" time="0.0045"/><testcase file="test/zebra/models/task_test.exs:80" classname="Elixir.Zebra.Models.TaskTest" name="test .find_by_id_or_request_token when the task can be found by id" time="0.0046"/><testcase file="test/zebra/models/task_test.exs:100" classname="Elixir.Zebra.Models.TaskTest" name="test .find_many_by_id_or_request_token it looks up by either id or request token" time="0.0136"/><testcase file="test/zebra/models/task_test.exs:18" classname="Elixir.Zebra.Models.TaskTest" name="test .update it updates updated_at" time="1.0078"/><testcase file="test/zebra/models/task_test.exs:92" classname="Elixir.Zebra.Models.TaskTest" name="test .find_by_id_or_request_token when the task can't be fount by either approches" time="0.0048"/><testcase file="test/zebra/models/task_test.exs:54" classname="Elixir.Zebra.Models.TaskTest" name="test .finished_at returns datetime when the last job was finished" time="0.0074"/><testcase file="test/zebra/models/task_test.exs:7" classname="Elixir.Zebra.Models.TaskTest" name="test .create it sets created_at and updated_at" time="0.0055"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" tests="8" time="0.0029"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:35" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 constructs triggerer with MANUAL_RUN workflow trigger" time="0.0000"/><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:82" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 constructs triggerer with manual promotion for debug job" time="0.0000"/><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:20" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 constructs triggerer with SCHEDULE workflow trigger" time="0.0000"/><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:64" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 constructs triggerer with manual promotion" time="0.0000"/><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:104" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 returns empty string for debug job with no triggerer environment variables" time="0.0000"/><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:7" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 constructs triggerer with API workflow trigger" time="0.0000"/><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:100" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 returns empty string for project debug job" time="0.0000"/><testcase file="test/zebra/workers/job_request_factory/open_id_connect_test.exs:51" classname="Elixir.Zebra.Workers.JobRequestFactory.OpenIDConnectTest" name="test construct_triggerer/1 constructs triggerer with HOOK workflow trigger" time="0.0028"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.SchedulerTest" tests="2" time="0.5862"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/scheduler_test.exs:61" classname="Elixir.Zebra.Workers.SchedulerTest" name="test calling the scheduler for a specific org" time="0.5114"/><testcase file="test/zebra/workers/scheduler_test.exs:26" classname="Elixir.Zebra.Workers.SchedulerTest" name="test scheduler" time="0.0748"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.CacheTest" tests="2" time="0.0087"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/cache_test.exs:45" classname="Elixir.Zebra.Workers.JobRequestFactory.CacheTest" name="test .env_vars cache_cli_parallel_archive_method is disabled => does not use parallel archive method" time="0.0044"/><testcase file="test/zebra/workers/job_request_factory/cache_test.exs:16" classname="Elixir.Zebra.Workers.JobRequestFactory.CacheTest" name="test .env_vars cache_cli_parallel_archive_method is enabled => uses parallel archive method" time="0.0043"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.SpecTest" tests="4" time="0.0156"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/spec_test.exs:25" classname="Elixir.Zebra.Workers.JobRequestFactory.SpecTest" name="test .env_vars when env vars count is not insane => encode env vars for agent" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/spec_test.exs:7" classname="Elixir.Zebra.Workers.JobRequestFactory.SpecTest" name="test .env_vars when env vars count is insane => stop job processing" time="0.0042"/><testcase file="test/zebra/workers/job_request_factory/spec_test.exs:56" classname="Elixir.Zebra.Workers.JobRequestFactory.SpecTest" name="test .epilogue epilogue_always_commands are not in the spec" time="0.0042"/><testcase file="test/zebra/workers/job_request_factory/spec_test.exs:44" classname="Elixir.Zebra.Workers.JobRequestFactory.SpecTest" name="test .epilogue epilogue_always_commands are in the spec" time="0.0036"/></testsuite><testsuite errors="0" failures="5" skipped="0" name="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" tests="9" time="0.0646"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:104" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message raises when org_id is not a valid UUID" time="0.0105"/><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:185" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message uses minimum grace period (7 days) when configured below minimum" time="0.0052"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  2) test .handle_message uses minimum grace period (7 days) when configured below minimum (Zebra.Workers.JobDeletionPolicyMarkerTest)
     test/zebra/workers/job_deletion_policy_marker_test.exs:185
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: Worker.handle_message(message)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/job_deletion_policy_marker.ex:24: Zebra.Workers.JobDeletionPolicyMarker.handle_message/1
       test/zebra/workers/job_deletion_policy_marker_test.exs:213: (test)
</failure></testcase><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:87" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message raises when org_id is empty string (proto3 default)" time="0.0041"/><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:151" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message uses default grace period (14 days) when days value is missing" time="0.0055"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  4) test .handle_message uses default grace period (14 days) when days value is missing (Zebra.Workers.JobDeletionPolicyMarkerTest)
     test/zebra/workers/job_deletion_policy_marker_test.exs:151
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: Worker.handle_message(message)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/job_deletion_policy_marker.ex:24: Zebra.Workers.JobDeletionPolicyMarker.handle_message/1
       test/zebra/workers/job_deletion_policy_marker_test.exs:179: (test)
</failure></testcase><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:253" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message uses minimum grace period (7 days) when days is zero" time="0.0054"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  5) test .handle_message uses minimum grace period (7 days) when days is zero (Zebra.Workers.JobDeletionPolicyMarkerTest)
     test/zebra/workers/job_deletion_policy_marker_test.exs:253
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: Worker.handle_message(message)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/job_deletion_policy_marker.ex:24: Zebra.Workers.JobDeletionPolicyMarker.handle_message/1
       test/zebra/workers/job_deletion_policy_marker_test.exs:281: (test)
</failure></testcase><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:75" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message raises when cutoff date is missing" time="0.0058"/><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:219" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message uses default grace period (14 days) when days is invalid" time="0.0063"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  7) test .handle_message uses default grace period (14 days) when days is invalid (Zebra.Workers.JobDeletionPolicyMarkerTest)
     test/zebra/workers/job_deletion_policy_marker_test.exs:219
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: Worker.handle_message(message)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/job_deletion_policy_marker.ex:24: Zebra.Workers.JobDeletionPolicyMarker.handle_message/1
       test/zebra/workers/job_deletion_policy_marker_test.exs:247: (test)
</failure></testcase><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:119" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message uses default grace period (14 days) when configuration is missing" time="0.0128"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  8) test .handle_message uses default grace period (14 days) when configuration is missing (Zebra.Workers.JobDeletionPolicyMarkerTest)
     test/zebra/workers/job_deletion_policy_marker_test.exs:119
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: Worker.handle_message(message)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/job_deletion_policy_marker.ex:24: Zebra.Workers.JobDeletionPolicyMarker.handle_message/1
       test/zebra/workers/job_deletion_policy_marker_test.exs:145: (test)
</failure></testcase><testcase file="test/zebra/workers/job_deletion_policy_marker_test.exs:20" classname="Elixir.Zebra.Workers.JobDeletionPolicyMarkerTest" name="test .handle_message marks eligible jobs for deletion" time="0.0090"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.Test" tests="2" time="0.0000"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers_test.exs:27" classname="Elixir.Zebra.Workers.Test" name="test with environment variables set active workers are returned" time="0.0000"/><testcase file="test/zebra/workers_test.exs:4" classname="Elixir.Zebra.Workers.Test" name="test no environment variables set => only default workers start" time="0.0000"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.Scheduler.OrgTest" tests="3" time="3.0614"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/scheduler/org_test.exs:14" classname="Elixir.Zebra.Workers.Scheduler.OrgTest" name="test load with error handling returns data without caching when error is returned" time="0.0073"/><testcase file="test/zebra/workers/scheduler/org_test.exs:64" classname="Elixir.Zebra.Workers.Scheduler.OrgTest" name="test load with error handling caches successful responses" time="0.0437"/><testcase file="test/zebra/workers/scheduler/org_test.exs:38" classname="Elixir.Zebra.Workers.Scheduler.OrgTest" name="test load with error handling properly handles timeouts and doesn't cache them" time="3.0104"/></testsuite><testsuite errors="0" failures="46" skipped="0" name="Elixir.Zebra.Api.PublicJobApiTest" tests="62" time="1.7313"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/public_job_api_test.exs:496" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on default branch => raise error" time="0.0078"><failure message="Assertion with == failed">  1) test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on default branch =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:496
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to attach jobs on the default branch of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:502: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:460" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when job is self-hosted => raise error" time="0.0072"/><testcase file="test/zebra/apis/public_job_api_test.exs:1219" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_project when project api fails => raise error" time="0.0063"><failure message="Assertion with == failed">  3) test .create_debug_project when project api fails =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1219
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1235: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:442" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the user is not authorized to see the job => returns not found" time="0.0066"/><testcase file="test/zebra/apis/public_job_api_test.exs:258" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job when the job is present and user can access it => returns serialized job" time="0.0073"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  5) test .get_job when the job is present and user can access it =&gt; returns serialized job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:258
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.get_job(request, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:269: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1290" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .stop_job idempotent requests" time="0.0076"><failure message="match (=) failed">  6) test .stop_job idempotent requests (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1290
     match (=) failed
     code:  assert {:ok, %Semaphore.Jobs.V1alpha.Empty{}} = channel |&gt; Stub.stop_job(request, @options)
     left:  {:ok, %Semaphore.Jobs.V1alpha.Empty{}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1308: anonymous fn/3 in Zebra.Api.PublicJobApiTest."test .stop_job idempotent requests"/1
       (elixir 1.13.4) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.4) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.4) lib/enum.ex:2400: Enum.each/2
       test/zebra/apis/public_job_api_test.exs:1307: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:938" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and blocks debug on pull request => raise error" time="0.0087"><failure message="Assertion with == failed">  7) test .create_debug_job when the project belongs to restricted org and blocks debug on pull request =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:938
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to debug jobs on a pull request of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:942: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:329" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job when the user is not authorized to see the job => returns not found" time="0.0063"/><testcase file="test/zebra/apis/public_job_api_test.exs:791" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the user can't create a pipeline => raise error" time="0.0076"/><testcase file="test/zebra/apis/public_job_api_test.exs:530" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on non default branch => gets the key" time="0.0586"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 10) test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on non default branch =&gt; gets the key (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:530
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: get_job_debug_ssh_key_passes_permission_check(task.id)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1433: Zebra.Api.PublicJobApiTest.get_job_debug_ssh_key_passes_permission_check/1
       test/zebra/apis/public_job_api_test.exs:537: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1094" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the user can access the project => creates job" time="0.0098"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 11) test .create_debug_job when the user can access the project =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1094
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.create_debug_job(req, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1110: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:341" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job if a job is restricted do not return configuration in spec" time="0.0076"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 12) test .get_job if a job is restricted do not return configuration in spec (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:341
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.get_job(request, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:353: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1194" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_project when organization api fails => raise error" time="0.0063"><failure message="Assertion with == failed"> 13) test .create_debug_project when organization api fails =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1194
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: "Error looking up #{@org_id}", status: 13}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Error looking up b4751d3c-539c-429f-a618-2f4cdef6792f", status: 13}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1213: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:249" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job when the job_id is not uuid => return invalid argument" time="0.0054"/><testcase file="test/zebra/apis/public_job_api_test.exs:1056" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when project api fails with metadata error => raise error" time="0.0093"><failure message="Assertion with == failed"> 15) test .create_debug_job when project api fails with metadata error =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1056
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1088: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:955" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and blocks debug on forked pull request => raise error" time="0.0089"><failure message="Assertion with == failed"> 16) test .create_debug_job when the project belongs to restricted org and blocks debug on forked pull request =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:955
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to debug jobs on a forked pull request of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:959: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:766" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_job when a self-hosted agent type is used => raise error" time="0.0052"/><testcase file="test/zebra/apis/public_job_api_test.exs:673" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_job empty name => raise error" time="0.0063"/><testcase file="test/zebra/apis/public_job_api_test.exs:947" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and allows debug on pull request => creates job" time="0.0091"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 19) test .create_debug_job when the project belongs to restricted org and allows debug on pull request =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:947
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: create_debug_job_passes_permission_check()
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1479: Zebra.Api.PublicJobApiTest.create_debug_job_passes_permission_check/0
       test/zebra/apis/public_job_api_test.exs:952: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:738" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_job when the user can access the project => creates job" time="0.0075"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 20) test .create_job when the user can access the project =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:738
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.create_job(job, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:758: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1117" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the original job is restricted => raise error" time="0.0077"/><testcase file="test/zebra/apis/public_job_api_test.exs:1264" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .stop_job when the job is present and user can access it => requests an async stop" time="0.0081"><failure message="match (=) failed"> 22) test .stop_job when the job is present and user can access it =&gt; requests an async stop (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1264
     match (=) failed
     code:  assert {:ok, %Semaphore.Jobs.V1alpha.Empty{}} = channel |&gt; Stub.stop_job(request, @options)
     left:  {:ok, %Semaphore.Jobs.V1alpha.Empty{}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1282: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1144" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_project when the user can't create a pipeline => raise error" time="0.0087"><failure message="Assertion with == failed"> 23) test .create_debug_project when the user can't create a pipeline =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1144
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{
              message: "You are not allowed to run pipelines on this project",
              status: 7
            }
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to run pipelines on this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1174: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:701" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_job when the user can't create a pipeline => raise error" time="0.0063"/><testcase file="test/zebra/apis/public_job_api_test.exs:508" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on default branch => gets the key" time="0.0890"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 25) test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on default branch =&gt; gets the key (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:508
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: get_job_debug_ssh_key_passes_permission_check(task.id)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1433: Zebra.Api.PublicJobApiTest.get_job_debug_ssh_key_passes_permission_check/1
       test/zebra/apis/public_job_api_test.exs:515: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:858" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and blocks debug on tag => raise error" time="0.0111"><failure message="Assertion with == failed"> 26) test .create_debug_job when the project belongs to restricted org and blocks debug on tag =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:858
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to debug jobs on a tag of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:862: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:168" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .list_jobs lists only authorized jobs" time="0.0080"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 27) test .list_jobs lists only authorized jobs (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:168
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.list_jobs(request, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:184: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:87" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .list_jobs when page_size is too high => it returns error" time="0.0056"/><testcase file="test/zebra/apis/public_job_api_test.exs:1333" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .stop_job when the user is not authorized to see the job => returns not found" time="0.0081"/><testcase file="test/zebra/apis/public_job_api_test.exs:972" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when organization api fails => raise error" time="0.0136"><failure message="Assertion with == failed"> 30) test .create_debug_job when organization api fails =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:972
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: "Error looking up #{@org_id}", status: 13}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Error looking up b4751d3c-539c-429f-a618-2f4cdef6792f", status: 13}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:994: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:606" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and blocks debug on project => raise error" time="0.0086"><failure message="Assertion with == failed"> 31) test .get_job_debug_ssh_key when the project belongs to restricted org and blocks debug on project =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:606
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to debug this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:609: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:562" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on pull request => raise error" time="0.0098"><failure message="Assertion with == failed"> 32) test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on pull request =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:562
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to attach jobs on a pull request of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:568: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:615" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and allows debug on project => gets the key" time="0.2743"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 33) test .get_job_debug_ssh_key when the project belongs to restricted org and allows debug on project =&gt; gets the key (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:615
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: get_job_debug_ssh_key_passes_permission_check(nil)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1433: Zebra.Api.PublicJobApiTest.get_job_debug_ssh_key_passes_permission_check/1
       test/zebra/apis/public_job_api_test.exs:619: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:518" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on non default branch => raise error" time="0.0086"><failure message="Assertion with == failed"> 34) test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on non default branch =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:518
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to attach jobs on non default branches of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:524: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:824" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and blocks debug on default branch => raise error" time="0.0095"><failure message="Assertion with == failed"> 35) test .create_debug_job when the project belongs to restricted org and blocks debug on default branch =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:824
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to debug jobs on the default branch of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:828: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:316" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job when the job is not found => returns not found" time="0.0102"/><testcase file="test/zebra/apis/public_job_api_test.exs:645" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the job is restricted => raise error" time="0.1157"/><testcase file="test/zebra/apis/public_job_api_test.exs:1186" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_project when the project belongs to restricted org and allows empty debug=> creates job" time="0.0060"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 38) test .create_debug_project when the project belongs to restricted org and allows empty debug=&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1186
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: create_debug_project_passes_permission_check()
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1529: Zebra.Api.PublicJobApiTest.create_debug_project_passes_permission_check/0
       test/zebra/apis/public_job_api_test.exs:1191: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:429" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the job is not found => returns not found" time="0.0056"/><testcase file="test/zebra/apis/public_job_api_test.exs:905" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when deployment target forbids user => raise error" time="0.0101"><failure message="Assertion with == failed"> 40) test .create_debug_job when deployment target forbids user =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:905
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{
              message: "You are not allowed to access Deployment Target[#{@dt_id}]: BANNED_SUBJECT",
              status: 7
            }
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to access Deployment Target[cc1a7237-04f7-4fb4-b517-58ce0475efa9]: BANNED_SUBJECT", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:931: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:574" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on pull request => gets the key" time="0.1961"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 41) test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on pull request =&gt; gets the key (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:574
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: get_job_debug_ssh_key_passes_permission_check(task.id)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1433: Zebra.Api.PublicJobApiTest.get_job_debug_ssh_key_passes_permission_check/1
       test/zebra/apis/public_job_api_test.exs:581: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:105" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .list_jobs when every parameter is correct => it returns list of jobs" time="0.0068"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 42) test .list_jobs when every parameter is correct =&gt; it returns list of jobs (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:105
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.list_jobs(request, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:119: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:540" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on tag => raise error" time="0.0088"><failure message="Assertion with == failed"> 43) test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on tag =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:540
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to attach jobs on a tag of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:546: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:596" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on forked pull request => gets the key" time="0.0605"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 44) test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on forked pull request =&gt; gets the key (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:596
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: get_job_debug_ssh_key_passes_permission_check(task.id)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1433: Zebra.Api.PublicJobApiTest.get_job_debug_ssh_key_passes_permission_check/1
       test/zebra/apis/public_job_api_test.exs:603: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:841" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and blocks debug on non default branch => raise error" time="0.0086"><failure message="Assertion with == failed"> 45) test .create_debug_job when the project belongs to restricted org and blocks debug on non default branch =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:841
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to debug jobs on non default branches of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:845: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:484" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and have default permissions => raise error" time="0.0083"><failure message="Assertion with == failed"> 46) test .get_job_debug_ssh_key when the project belongs to restricted org and have default permissions =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:484
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to attach jobs on the default branch of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:490: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1028" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when project api fails => raise error" time="0.0094"><failure message="Assertion with == failed"> 47) test .create_debug_job when project api fails =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1028
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1050: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1317" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .stop_job when the job is not found => returns not found" time="0.0089"/><testcase file="test/zebra/apis/public_job_api_test.exs:867" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and allows debug on tag => creates job" time="0.0096"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 49) test .create_debug_job when the project belongs to restricted org and allows debug on tag =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:867
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: create_debug_job_passes_permission_check()
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1479: Zebra.Api.PublicJobApiTest.create_debug_job_passes_permission_check/0
       test/zebra/apis/public_job_api_test.exs:872: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:964" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and allows debug on forked pull request => creates job" time="0.0086"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 50) test .create_debug_job when the project belongs to restricted org and allows debug on forked pull request =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:964
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: create_debug_job_passes_permission_check()
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1479: Zebra.Api.PublicJobApiTest.create_debug_job_passes_permission_check/0
       test/zebra/apis/public_job_api_test.exs:969: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:833" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and allows debug on default branch => creates job" time="0.0088"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 51) test .create_debug_job when the project belongs to restricted org and allows debug on default branch =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:833
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: create_debug_job_passes_permission_check()
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1479: Zebra.Api.PublicJobApiTest.create_debug_job_passes_permission_check/0
       test/zebra/apis/public_job_api_test.exs:838: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:875" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when deployment target API fails => raise error" time="0.0089"><failure message="Assertion with == failed"> 52) test .create_debug_job when deployment target API fails =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:875
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{
              message: "Unable to verify access to deployment target #{@dt_id}",
              status: 13
            }
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Unable to verify access to deployment target cc1a7237-04f7-4fb4-b517-58ce0475efa9", status: 13}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:899: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1241" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_project when the user can access the project => creates job" time="0.0065"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 53) test .create_debug_project when the user can access the project =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1241
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.create_debug_project(req, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1255: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:552" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on tag => gets the key" time="0.1347"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 54) test .get_job_debug_ssh_key when the project belongs to restricted org and allows attach on tag =&gt; gets the key (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:552
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: get_job_debug_ssh_key_passes_permission_check(task.id)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1433: Zebra.Api.PublicJobApiTest.get_job_debug_ssh_key_passes_permission_check/1
       test/zebra/apis/public_job_api_test.exs:559: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1180" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_project when the project belongs to restricted org and blocks empty debug session => raise error" time="0.0095"><failure message="Assertion with == failed"> 55) test .create_debug_project when the project belongs to restricted org and blocks empty debug session =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1180
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to debug this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1183: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:622" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the job is not running => return not found" time="0.1078"><failure message="Assertion with == failed"> 56) test .get_job_debug_ssh_key when the job is not running =&gt; return not found (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:622
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{
              message: "Job's debug SSH is only available while the job is running",
              status: 9
            }
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Job's debug SSH is only available while the job is running", status: 9}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:639: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:396" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the job_id is not uuid => return invalid argument" time="0.0044"/><testcase file="test/zebra/apis/public_job_api_test.exs:584" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on forked pull request => raise error" time="0.0084"><failure message="Assertion with == failed"> 58) test .get_job_debug_ssh_key when the project belongs to restricted org and blocks attach on forked pull request =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:584
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: message, status: 7}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "You are not allowed to attach jobs on a forked pull request of this project", status: 7}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:590: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:1000" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when repo proxy api fails => raise error" time="0.0102"><failure message="Assertion with == failed"> 59) test .create_debug_job when repo proxy api fails =&gt; raise error (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:1000
     Assertion with == failed
     code:  assert reply == %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "Error checking org permissions", status: 13}
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1022: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:850" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .create_debug_job when the project belongs to restricted org and allows debug on non default branch => creates job" time="0.0150"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 60) test .create_debug_job when the project belongs to restricted org and allows debug on non default branch =&gt; creates job (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:850
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: create_debug_job_passes_permission_check()
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:1479: Zebra.Api.PublicJobApiTest.create_debug_job_passes_permission_check/0
       test/zebra/apis/public_job_api_test.exs:855: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:189" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .list_jobs if a job is restricted do not return configuration in spec" time="0.0243"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 61) test .list_jobs if a job is restricted do not return configuration in spec (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:189
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.list_jobs(request, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:204: (test)
</failure></testcase><testcase file="test/zebra/apis/public_job_api_test.exs:407" classname="Elixir.Zebra.Api.PublicJobApiTest" name="test .get_job_debug_ssh_key when the job is present and running => return key" time="0.2434"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 62) test .get_job_debug_ssh_key when the job is present and running =&gt; return key (Zebra.Api.PublicJobApiTest)
     test/zebra/apis/public_job_api_test.exs:407
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = channel |&gt; Stub.get_job_debug_ssh_key(request, @options)
     stacktrace:
       test/zebra/apis/public_job_api_test.exs:422: (test)
</failure></testcase></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.TaskFailFastTest" tests="10" time="0.1635"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/task_fail_fast_test.exs:115" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .query when the strategy is cancel => return all non-started jobs" time="0.0082"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:197" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .tick when the task has no strategy" time="0.0100"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:88" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .query when the strategy is stop => return all non-finished jobs" time="0.0084"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:173" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .tick when the task has a stop strategy" time="0.0106"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:7" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .query it ignores tasks without fail-fast strategies" time="0.0075"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:238" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .tick when the task has cancel strategy but no failed jobs" time="0.0095"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:64" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .query it returns only jobs that have tasks with a failed job" time="0.0073"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:221" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .tick when the task has stop strategy but no failed jobs" time="0.0102"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:149" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .tick when the task has a cancel strategy" time="0.0180"/><testcase file="test/zebra/workers/task_fail_fast_test.exs:39" classname="Elixir.Zebra.Workers.TaskFailFastTest" name="test .query it returns only jobs that have no job_stop_requests" time="0.0738"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" tests="17" time="0.0838"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:108" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when longnaptime is zero" time="0.0040"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:151" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .tick respects the batch limit" time="0.0082"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:61" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when naptime is not a positive integer" time="0.0039"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:99" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when longnaptime is invalid (not integer or nil)" time="0.0037"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:55" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when naptime is missing" time="0.0039"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:70" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when naptime is negative" time="0.0040"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:135" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .tick returns false when nothing is eligible for deletion" time="0.0061"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:77" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when limit is missing" time="0.0043"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:193" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .tick returns false when no jobs have expired" time="0.0053"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:31" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link starts successfully with nil longnaptime" time="0.0039"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:92" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when limit is negative" time="0.0041"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:49" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when configuration is missing" time="0.0040"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:178" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .tick returns true when only stop requests are deleted" time="0.0070"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:22" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link starts successfully with valid configuration" time="0.0044"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:117" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .tick deletes expired jobs and related stop requests" time="0.0074"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:83" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link returns error when limit is not a positive integer" time="0.0040"/><testcase file="test/zebra/workers/job_deletion_policy_worker_test.exs:40" classname="Elixir.Zebra.Workers.JobDeletionPolicyWorkerTest" name="test .start_link starts successfully without longnaptime key" time="0.0056"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Apis.PublicJobApi.ListerTest" tests="7" time="0.0412"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/public_job_api/lister_test.exs:39" classname="Elixir.Zebra.Apis.PublicJobApi.ListerTest" name="test .list_jobs continuing the listing with a page_token" time="0.0095"/><testcase file="test/zebra/apis/public_job_api/lister_test.exs:116" classname="Elixir.Zebra.Apis.PublicJobApi.ListerTest" name="test .extract_page_size when page size is less then limit => returns page size" time="0.0043"/><testcase file="test/zebra/apis/public_job_api/lister_test.exs:8" classname="Elixir.Zebra.Apis.PublicJobApi.ListerTest" name="test .list_jobs filtering jobs by state" time="0.0075"/><testcase file="test/zebra/apis/public_job_api/lister_test.exs:112" classname="Elixir.Zebra.Apis.PublicJobApi.ListerTest" name="test .extract_page_size when page size is 0 => returns 30" time="0.0044"/><testcase file="test/zebra/apis/public_job_api/lister_test.exs:129" classname="Elixir.Zebra.Apis.PublicJobApi.ListerTest" name="test .map_state_names" time="0.0040"/><testcase file="test/zebra/apis/public_job_api/lister_test.exs:120" classname="Elixir.Zebra.Apis.PublicJobApi.ListerTest" name="test .extract_page_size when page size is less then limit => returns error" time="0.0040"/><testcase file="test/zebra/apis/public_job_api/lister_test.exs:73" classname="Elixir.Zebra.Apis.PublicJobApi.ListerTest" name="test .list_jobs filtering by project id" time="0.0076"/></testsuite><testsuite errors="0" failures="1" skipped="0" name="Elixir.Zebra.UsagePublisherTest" tests="1" time="0.0104"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/usage_publisher_test.exs:5" classname="Elixir.Zebra.UsagePublisherTest" name="test stat collection" time="0.0104"><failure message="error: no match of right hand side value: {:error, {:shutdown, {%ArgumentError{message: &quot;errors were found at the given arguments:\n\n  * 1st argument: not a pid\n&quot;}, []}}}">  1) test stat collection (Zebra.UsagePublisherTest)
     test/zebra/usage_publisher_test.exs:5
     ** (MatchError) no match of right hand side value: {:error, {:shutdown, {%ArgumentError{message: "errors were found at the given arguments:\n\n  * 1st argument: not a pid\n"}, []}}}
     code: Zebra.UsagePublisher.load()
     stacktrace:
       (zebra 0.0.1) lib/zebra/usage_publisher.ex:30: anonymous fn/1 in Zebra.UsagePublisher.load/0
       (elixir 1.13.4) lib/enum.ex:1593: Enum."-map/2-lists^map/1-0-"/2
       test/zebra/usage_publisher_test.exs:17: (test)
</failure></testcase></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Machines.BrownoutTest" tests="5" time="0.0457"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/machines/brownout_test.exs:39" classname="Elixir.Zebra.Machines.BrownoutTest" name="test applying brownout on a schedule works on a schedule" time="0.0000"/><testcase file="test/zebra/machines/brownout_test.exs:34" classname="Elixir.Zebra.Machines.BrownoutTest" name="test applying brownout on a schedule ignores not browned out os images" time="0.0000"/><testcase file="test/zebra/machines/brownout_test.exs:88" classname="Elixir.Zebra.Machines.BrownoutTest" name="test applying brownout without configuration works" time="0.0000"/><testcase file="test/zebra/machines/brownout_test.exs:71" classname="Elixir.Zebra.Machines.BrownoutTest" name="test applying brownout on a schedule works with multiple os images" time="0.0431"/><testcase file="test/zebra/machines/brownout_test.exs:26" classname="Elixir.Zebra.Machines.BrownoutTest" name="test applying brownout on a schedule ignores excluded organizations" time="0.0025"/></testsuite><testsuite errors="0" failures="6" skipped="0" name="Elixir.Zebra.Models.JobTest" tests="51" time="3.4614"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/models/job_test.exs:84" classname="Elixir.Zebra.Models.JobTest" name="test .create when machine_os_image is blank => it sets the default os_image for the machine_type" time="0.0053"/><testcase file="test/zebra/models/job_test.exs:38" classname="Elixir.Zebra.Models.JobTest" name="test .create empty project_id => error" time="0.0042"/><testcase file="test/zebra/models/job_test.exs:543" classname="Elixir.Zebra.Models.JobTest" name="test .finish when the result is failed => finishes the job" time="0.0059"/><testcase file="test/zebra/models/job_test.exs:25" classname="Elixir.Zebra.Models.JobTest" name="test .create empty organization_id => error" time="0.0042"/><testcase file="test/zebra/models/job_test.exs:574" classname="Elixir.Zebra.Models.JobTest" name="test .detect_type when it is a pipeline job => pipeline_job" time="0.0051"/><testcase file="test/zebra/models/job_test.exs:353" classname="Elixir.Zebra.Models.JobTest" name="test .wait when the job is finished => error" time="0.0051"/><testcase file="test/zebra/models/job_test.exs:284" classname="Elixir.Zebra.Models.JobTest" name="test .schedule when the job is waiting => error" time="0.0049"/><testcase file="test/zebra/models/job_test.exs:134" classname="Elixir.Zebra.Models.JobTest" name="test .create it sets created_at and updated_at" time="0.0059"/><testcase file="test/zebra/models/job_test.exs:463" classname="Elixir.Zebra.Models.JobTest" name="test .stop stops self-hosted job" time="0.0095"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  9) test .stop stops self-hosted job (Zebra.Models.JobTest)
     test/zebra/models/job_test.exs:463
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: |&gt; Enum.each(fn job -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
       (zebra 0.0.1) lib/zebra/models/job.ex:534: Zebra.Models.Job.stop/1
       test/zebra/models/job_test.exs:476: anonymous fn/1 in Zebra.Models.JobTest."test .stop stops self-hosted job"/1
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/zebra/models/job_test.exs:475: (test)
</failure></testcase><testcase file="test/zebra/models/job_test.exs:533" classname="Elixir.Zebra.Models.JobTest" name="test .finish when the result is passed => finishes the job" time="0.0294"/><testcase file="test/zebra/models/job_test.exs:447" classname="Elixir.Zebra.Models.JobTest" name="test .stop it stops the job" time="2.0121"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 11) test .stop it stops the job (Zebra.Models.JobTest)
     test/zebra/models/job_test.exs:447
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: |&gt; Enum.each(fn job -&gt;
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/agent/hosted_agent.ex:35: Zebra.Workers.Agent.HostedAgent.send/5
       (zebra 0.0.1) lib/zebra/models/job.ex:533: Zebra.Models.Job.stop/1
       test/zebra/models/job_test.exs:456: anonymous fn/1 in Zebra.Models.JobTest."test .stop it stops the job"/1
       (elixir 1.13.4) lib/enum.ex:937: Enum."-each/2-lists^foreach/1-0-"/2
       test/zebra/models/job_test.exs:455: (test)
</failure></testcase><testcase file="test/zebra/models/job_test.exs:373" classname="Elixir.Zebra.Models.JobTest" name="test .start when the job is enqueued => error" time="0.0050"/><testcase file="test/zebra/models/job_test.exs:278" classname="Elixir.Zebra.Models.JobTest" name="test .schedule when the job is scheduled => transitions" time="0.0051"/><testcase file="test/zebra/models/job_test.exs:256" classname="Elixir.Zebra.Models.JobTest" name="test .enqueue when the job is finished => error" time="0.0050"/><testcase file="test/zebra/models/job_test.exs:361" classname="Elixir.Zebra.Models.JobTest" name="test .start when the job is pending => error" time="0.0046"/><testcase file="test/zebra/models/job_test.exs:270" classname="Elixir.Zebra.Models.JobTest" name="test .schedule when the job is enqueued => error" time="0.0057"/><testcase file="test/zebra/models/job_test.exs:483" classname="Elixir.Zebra.Models.JobTest" name="test .stop stops self-hosted job even if self hosted grpc endpoint fails" time="0.0061"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 17) test .stop stops self-hosted job even if self hosted grpc endpoint fails (Zebra.Models.JobTest)
     test/zebra/models/job_test.exs:483
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert {:ok, job} = Job.stop(job)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
       (zebra 0.0.1) lib/zebra/models/job.ex:534: Zebra.Models.Job.stop/1
       test/zebra/models/job_test.exs:490: (test)
</failure></testcase><testcase file="test/zebra/models/job_test.exs:559" classname="Elixir.Zebra.Models.JobTest" name="test .finish tries to finish the task" time="0.0069"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 18) test .finish tries to finish the task (Zebra.Models.JobTest)
     test/zebra/models/job_test.exs:559
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert {:ok, job} = Job.finish(job, "passed")
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/task_finisher.ex:86: Zebra.Workers.TaskFinisher.finish/3
       (zebra 0.0.1) lib/zebra/workers/task_finisher.ex:66: anonymous fn/1 in Zebra.Workers.TaskFinisher.process/1
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       (ecto_sql 3.7.2) lib/ecto/adapters/sql.ex:1021: anonymous fn/3 in Ecto.Adapters.SQL.checkout_or_transaction/4
       (db_connection 2.6.0) lib/db_connection.ex:1710: DBConnection.run_transaction/4
       (zebra 0.0.1) lib/zebra/models/job.ex:513: Zebra.Models.Job.finish/2
       test/zebra/models/job_test.exs:563: (test)
</failure></testcase><testcase file="test/zebra/models/job_test.exs:496" classname="Elixir.Zebra.Models.JobTest" name="test .stop tries to finish the task" time="0.0063"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 19) test .stop tries to finish the task (Zebra.Models.JobTest)
     test/zebra/models/job_test.exs:496
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert {:ok, job} = Job.stop(job)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/task_finisher.ex:86: Zebra.Workers.TaskFinisher.finish/3
       (zebra 0.0.1) lib/zebra/workers/task_finisher.ex:66: anonymous fn/1 in Zebra.Workers.TaskFinisher.process/1
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       (ecto_sql 3.7.2) lib/ecto/adapters/sql.ex:1021: anonymous fn/3 in Ecto.Adapters.SQL.checkout_or_transaction/4
       (db_connection 2.6.0) lib/db_connection.ex:1710: DBConnection.run_transaction/4
       (zebra 0.0.1) lib/zebra/models/job.ex:548: Zebra.Models.Job.stop/1
       test/zebra/models/job_test.exs:500: (test)
</failure></testcase><testcase file="test/zebra/models/job_test.exs:264" classname="Elixir.Zebra.Models.JobTest" name="test .schedule when the job is pending => error" time="0.0047"/><testcase file="test/zebra/models/job_test.exs:107" classname="Elixir.Zebra.Models.JobTest" name="test .create when machine_os_image is blank and the machine type is unknown => it leaves the os_image blank" time="0.0046"/><testcase file="test/zebra/models/job_test.exs:328" classname="Elixir.Zebra.Models.JobTest" name="test .wait when the job is enqueued => error" time="0.0047"/><testcase file="test/zebra/models/job_test.exs:588" classname="Elixir.Zebra.Models.JobTest" name="test .detect_type when it is a project level debug job => project_debug_job" time="0.0048"/><testcase file="test/zebra/models/job_test.exs:402" classname="Elixir.Zebra.Models.JobTest" name="test .start when the job is waiting => transitions" time="0.0053"/><testcase file="test/zebra/models/job_test.exs:232" classname="Elixir.Zebra.Models.JobTest" name="test .enqueue when the job is enqueued => error" time="0.0048"/><testcase file="test/zebra/models/job_test.exs:177" classname="Elixir.Zebra.Models.JobTest" name="test .force_finish forcefully finished the job with failed status and a reason" time="0.0054"/><testcase file="test/zebra/models/job_test.exs:238" classname="Elixir.Zebra.Models.JobTest" name="test .enqueue when the job is scheduled => error" time="0.0047"/><testcase file="test/zebra/models/job_test.exs:120" classname="Elixir.Zebra.Models.JobTest" name="test .create when the machine_os_image is set => it leaves it intact" time="0.0044"/><testcase file="test/zebra/models/job_test.exs:290" classname="Elixir.Zebra.Models.JobTest" name="test .schedule when the job is started => error" time="0.0047"/><testcase file="test/zebra/models/job_test.exs:250" classname="Elixir.Zebra.Models.JobTest" name="test .enqueue when the job is started => error" time="0.0047"/><testcase file="test/zebra/models/job_test.exs:527" classname="Elixir.Zebra.Models.JobTest" name="test .finish when job is already finished => error" time="0.0049"/><testcase file="test/zebra/models/job_test.exs:12" classname="Elixir.Zebra.Models.JobTest" name="test .create empty name => error" time="0.0042"/><testcase file="test/zebra/models/job_test.exs:347" classname="Elixir.Zebra.Models.JobTest" name="test .wait when the job is started => error" time="0.0054"/><testcase file="test/zebra/models/job_test.exs:187" classname="Elixir.Zebra.Models.JobTest" name="test .force_finish tries to finish the task" time="0.0081"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
"> 34) test .force_finish tries to finish the task (Zebra.Models.JobTest)
     test/zebra/models/job_test.exs:187
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert {:ok, job} = Job.force_finish(job, "Santa said that he was naughty")
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (zebra 0.0.1) lib/zebra/workers/task_finisher.ex:86: Zebra.Workers.TaskFinisher.finish/3
       (zebra 0.0.1) lib/zebra/workers/task_finisher.ex:66: anonymous fn/1 in Zebra.Workers.TaskFinisher.process/1
       (stdlib 3.17.2.4) timer.erl:166: :timer.tc/1
       (watchman 0.2.0) lib/watchman.ex:36: Watchman.benchmark/2
       (ecto_sql 3.7.2) lib/ecto/adapters/sql.ex:1021: anonymous fn/3 in Ecto.Adapters.SQL.checkout_or_transaction/4
       (db_connection 2.6.0) lib/db_connection.ex:1710: DBConnection.run_transaction/4
       (zebra 0.0.1) lib/zebra/models/job.ex:283: Zebra.Models.Job.force_finish/2
       test/zebra/models/job_test.exs:191: (test)
</failure></testcase><testcase file="test/zebra/models/job_test.exs:152" classname="Elixir.Zebra.Models.JobTest" name="test .update it updates updated_at" time="1.0081"/><testcase file="test/zebra/models/job_test.exs:223" classname="Elixir.Zebra.Models.JobTest" name="test .enqueue when the job is pending => saves request" time="0.1590"/><testcase file="test/zebra/models/job_test.exs:304" classname="Elixir.Zebra.Models.JobTest" name="test .bulk_schedule schedules jobs in a bulk" time="0.0058"/><testcase file="test/zebra/models/job_test.exs:51" classname="Elixir.Zebra.Models.JobTest" name="test .create creates a new job" time="0.0047"/><testcase file="test/zebra/models/job_test.exs:433" classname="Elixir.Zebra.Models.JobTest" name="test .start when the job is finished => error" time="0.0045"/><testcase file="test/zebra/models/job_test.exs:581" classname="Elixir.Zebra.Models.JobTest" name="test .detect_type when it is a debug job => debug_job" time="0.0050"/><testcase file="test/zebra/models/job_test.exs:334" classname="Elixir.Zebra.Models.JobTest" name="test .wait when the job is scheduled => transitions" time="0.0050"/><testcase file="test/zebra/models/job_test.exs:385" classname="Elixir.Zebra.Models.JobTest" name="test .start when the job is scheduled => transitions" time="0.0051"/><testcase file="test/zebra/models/job_test.exs:296" classname="Elixir.Zebra.Models.JobTest" name="test .schedule when the job is finished => error" time="0.0048"/><testcase file="test/zebra/models/job_test.exs:341" classname="Elixir.Zebra.Models.JobTest" name="test .wait when the job is waiting => error" time="0.0049"/><testcase file="test/zebra/models/job_test.exs:553" classname="Elixir.Zebra.Models.JobTest" name="test .finish when the result is nil => error" time="0.0047"/><testcase file="test/zebra/models/job_test.exs:166" classname="Elixir.Zebra.Models.JobTest" name="test .update it updates the fields" time="0.0054"/><testcase file="test/zebra/models/job_test.exs:511" classname="Elixir.Zebra.Models.JobTest" name="test .finish when job is in any other state => transitions" time="0.0102"/><testcase file="test/zebra/models/job_test.exs:244" classname="Elixir.Zebra.Models.JobTest" name="test .enqueue when the job is waiting => error" time="0.0046"/><testcase file="test/zebra/models/job_test.exs:203" classname="Elixir.Zebra.Models.JobTest" name="test .bulk_force_finish force fails a list of jobs" time="0.0074"/><testcase file="test/zebra/models/job_test.exs:421" classname="Elixir.Zebra.Models.JobTest" name="test .start when the job is started => error" time="0.0052"/><testcase file="test/zebra/models/job_test.exs:322" classname="Elixir.Zebra.Models.JobTest" name="test .wait when the job is pending => error" time="0.0054"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Apis.InternalTaskApi.SerializerTest" tests="4" time="0.0309"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/internal_task_api/serializer_test.exs:51" classname="Elixir.Zebra.Apis.InternalTaskApi.SerializerTest" name="test .serialize when the task is finished => returns finished_at = nil" time="0.0046"/><testcase file="test/zebra/apis/internal_task_api/serializer_test.exs:9" classname="Elixir.Zebra.Apis.InternalTaskApi.SerializerTest" name="test .serialize task serialization" time="0.0066"/><testcase file="test/zebra/apis/internal_task_api/serializer_test.exs:72" classname="Elixir.Zebra.Apis.InternalTaskApi.SerializerTest" name="test .serialize_job job serialization" time="0.0079"/><testcase file="test/zebra/apis/internal_task_api/serializer_test.exs:59" classname="Elixir.Zebra.Apis.InternalTaskApi.SerializerTest" name="test .serialize when the task is not finished => returns finished_at = updated_at" time="0.0118"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Apis.PublicJobApi.DebugTest" tests="1" time="0.0058"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/public_job_api/debug_test.exs:10" classname="Elixir.Zebra.Apis.PublicJobApi.DebugTest" name="test .debug_job_params copy everything from job, except commands" time="0.0058"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobStopperTest" tests="5" time="2.0410"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_stopper_test.exs:36" classname="Elixir.Zebra.Workers.JobStopperTest" name="test .request_stop_for_all_jobs_in_task_async it schedules multiple job stop requests" time="0.0071"/><testcase file="test/zebra/workers/job_stopper_test.exs:17" classname="Elixir.Zebra.Workers.JobStopperTest" name="test .request_stop_async it doesn't store duplicate requests" time="0.0078"/><testcase file="test/zebra/workers/job_stopper_test.exs:83" classname="Elixir.Zebra.Workers.JobStopperTest" name="test .process when job is running" time="2.0116"/><testcase file="test/zebra/workers/job_stopper_test.exs:57" classname="Elixir.Zebra.Workers.JobStopperTest" name="test .request_stop_for_all_jobs_in_task_async it is idempotent" time="0.0089"/><testcase file="test/zebra/workers/job_stopper_test.exs:12" classname="Elixir.Zebra.Workers.JobStopperTest" name="test .request_stop_async it schedules a job stop request" time="0.0055"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactoryTest" tests="16" time="1.6383"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory_test.exs:1308" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when the organization service raises an exception => doesn't process the job" time="0.0667"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1354" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when the cache service raises an exception => ignore it" time="0.1555"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1214" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when project doesn't exist => doesn't process the job" time="0.1378"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1293" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when we can't find a secret => force fails the job" time="0.0680"/><testcase file="test/zebra/workers/job_request_factory_test.exs:942" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when pending job with containers definition exists => creates job req" time="0.0917"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1236" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when we can't connect to project api => doesn't process the job" time="0.1398"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1342" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when the artifacthub service raises an exception => doesn't process the job" time="0.0870"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1249" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when we can't connect to loghub2 api => doesn't process self-hosted job" time="0.0114"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1391" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when we can't connect to repo_proxy api => doesn't process the job" time="0.1026"/><testcase file="test/zebra/workers/job_request_factory_test.exs:251" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when pending job with spec exists => creates job req" time="0.0889"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1280" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when we can't connect to secrets api => doesn't process the job" time="0.1759"/><testcase file="test/zebra/workers/job_request_factory_test.exs:731" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test self-hosted when pending self-hosted job with spec exists => creates job req" time="0.0156"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1367" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when the cache key is invalid => don't include it" time="0.0599"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1321" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when the organization doesn't exist => doesn't process the job" time="0.0521"/><testcase file="test/zebra/workers/job_request_factory_test.exs:1268" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when we can't connect to loghub2 api => process hosted job" time="0.1526"/><testcase file="test/zebra/workers/job_request_factory_test.exs:491" classname="Elixir.Zebra.Workers.JobRequestFactoryTest" name="test when pending debug job with spec exists => creates job req" time="0.2329"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" tests="12" time="0.0485"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:115" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .map_status_agent pending job => no agent is serialized" time="0.0038"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:130" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .map_status_agent started job => agent is serialized" time="0.0036"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:8" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .serialize" time="0.0050"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:94" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .request_git_vars unrecognized request structure returns empty list" time="0.0038"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:48" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .map_state" time="0.0042"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:125" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .map_status_agent scheduled job => no agent is serialized" time="0.0039"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:57" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .request_git_vars nil => []" time="0.0037"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:168" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .map_status_agent if port and ip aren't there, they are not serialized" time="0.0038"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:73" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .request_git_vars works for old job request" time="0.0041"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:149" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .map_status_agent finished job => agent is serialized" time="0.0039"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:120" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .map_status_agent enqueued job => no agent is serialized" time="0.0041"/><testcase file="test/zebra/apis/public_job_api/serializer_test.exs:61" classname="Elixir.Zebra.Apis.PublicJobApi.SerializerTest" name="test .request_git_vars works for current job request" time="0.0047"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.RepositoryTest" tests="5" time="0.0211"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/repository_test.exs:90" classname="Elixir.Zebra.Workers.JobRequestFactory.RepositoryTest" name="test .env_vars when build this is a branch build" time="0.0043"/><testcase file="test/zebra/workers/job_request_factory/repository_test.exs:55" classname="Elixir.Zebra.Workers.JobRequestFactory.RepositoryTest" name="test .env_vars when there is no repo_proxy for project debug job" time="0.0047"/><testcase file="test/zebra/workers/job_request_factory/repository_test.exs:260" classname="Elixir.Zebra.Workers.JobRequestFactory.RepositoryTest" name="test .env_vars when build this is a tag build" time="0.0038"/><testcase file="test/zebra/workers/job_request_factory/repository_test.exs:165" classname="Elixir.Zebra.Workers.JobRequestFactory.RepositoryTest" name="test .env_vars when build this is a pr build" time="0.0037"/><testcase file="test/zebra/workers/job_request_factory/repository_test.exs:28" classname="Elixir.Zebra.Workers.JobRequestFactory.RepositoryTest" name="test .find uses repository api" time="0.0046"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobStartedCallbackWorkerTest" tests="4" time="0.0248"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_started_callback_worker_test.exs:32" classname="Elixir.Zebra.Workers.JobStartedCallbackWorkerTest" name="test .handle_message when the job is already started => no error" time="0.0054"/><testcase file="test/zebra/workers/job_started_callback_worker_test.exs:12" classname="Elixir.Zebra.Workers.JobStartedCallbackWorkerTest" name="test .handle_message when the job is waiting => handles a started callback message" time="0.0068"/><testcase file="test/zebra/workers/job_started_callback_worker_test.exs:68" classname="Elixir.Zebra.Workers.JobStartedCallbackWorkerTest" name="test .handle_message when job is not found => raise error" time="0.0050"/><testcase file="test/zebra/workers/job_started_callback_worker_test.exs:50" classname="Elixir.Zebra.Workers.JobStartedCallbackWorkerTest" name="test .handle_message when the job is already finished => no error" time="0.0076"/></testsuite><testsuite errors="0" failures="2" skipped="0" name="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" tests="8" time="0.0368"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:136" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .encode_fail_fast_strategy it converts to database friendly strings" time="0.0045"/><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:169" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .configure_execution_time_limit when feature is enabled and limit from request is valid => returns limit from request in seconds" time="0.0049"/><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:124" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .schedule second time scheduling with the same token => returns same task" time="0.0045"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  3) test .schedule second time scheduling with the same token =&gt; returns same task (Zebra.Apis.InternalTaskApi.ScheduleTest)
     test/zebra/apis/internal_task_api/schedule_test.exs:124
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert {:ok, task1} = Schedule.schedule(req)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
       (zebra 0.0.1) lib/zebra/apis/internal_task_api/schedule.ex:15: Zebra.Apis.InternalTaskApi.Schedule.schedule/1
       test/zebra/apis/internal_task_api/schedule_test.exs:128: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:154" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .configure_execution_time_limit when feature is disabled and limit from request is invalid => returns default limit in seconds" time="0.0038"/><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:191" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .configure_execution_time_limit when feature is enabled, limit from request is invalid, and feature limit &lt; default limit  => returns feature limit" time="0.0048"/><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:10" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .schedule it creates task with jobs" time="0.0061"><failure message="error: errors were found at the given arguments:

  * 1st argument: not a pid
">  6) test .schedule it creates task with jobs (Zebra.Apis.InternalTaskApi.ScheduleTest)
     test/zebra/apis/internal_task_api/schedule_test.exs:10
     ** (ArgumentError) errors were found at the given arguments:
     
       * 1st argument: not a pid
     
     code: assert {:ok, task} = Schedule.schedule(req)
     stacktrace:
       :erlang.process_info(nil, :message_queue_len)
       (elixir 1.13.4) lib/process.ex:773: Process.info/2
       (watchman 0.2.0) lib/watchman/server.ex:53: Watchman.Server.buffer_size/0
       (watchman 0.2.0) lib/watchman/server.ex:61: Watchman.Server.submit/3
       (watchman 0.2.0) lib/watchman.ex:37: Watchman.benchmark/2
       (zebra 0.0.1) lib/zebra/apis/internal_task_api/schedule.ex:15: Zebra.Apis.InternalTaskApi.Schedule.schedule/1
       test/zebra/apis/internal_task_api/schedule_test.exs:14: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:176" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .configure_execution_time_limit when feature is enabled, limit from request is invalid, and feature limit >= default limit  => returns default limit" time="0.0042"/><testcase file="test/zebra/apis/internal_task_api/schedule_test.exs:148" classname="Elixir.Zebra.Apis.InternalTaskApi.ScheduleTest" name="test .configure_execution_time_limit when feature is disabled and limit from request is valid => returns limit from request in seconds" time="0.0040"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.RSATest" tests="2" time="14.0963"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/rsa_test.exs:11" classname="Elixir.Zebra.RSATest" name="test repeated generation" time="13.9015"/><testcase file="test/zebra/rsa_test.exs:4" classname="Elixir.Zebra.RSATest" name="test generate" time="0.1948"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobTerminatorTest" tests="1" time="2.0245"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_terminator_test.exs:4" classname="Elixir.Zebra.Workers.JobTerminatorTest" name="test terminating jobs that exceeded execution time limit" time="2.0245"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.CacheTest" tests="5" time="5.0005"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/cache_test.exs:21" classname="Elixir.Zebra.CacheTest" name="test nil is not cached" time="0.0001"/><testcase file="test/zebra/cache_test.exs:9" classname="Elixir.Zebra.CacheTest" name="test timeout" time="5.0003"/><testcase file="test/zebra/cache_test.exs:31" classname="Elixir.Zebra.CacheTest" name="test if fallback returns {:commit, value} it's cached" time="0.0001"/><testcase file="test/zebra/cache_test.exs:26" classname="Elixir.Zebra.CacheTest" name="test if fallback returns {:ignore, value} it's not cached" time="0.0000"/><testcase file="test/zebra/cache_test.exs:4" classname="Elixir.Zebra.CacheTest" name="test it caches values" time="0.0000"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.ArtifacthubTest" tests="3" time="0.0149"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/artifacthub_test.exs:28" classname="Elixir.Zebra.Workers.JobRequestFactory.ArtifacthubTest" name="test .generate_token on nil, empty artifact storage => returns stop_job_processing" time="0.0051"/><testcase file="test/zebra/workers/job_request_factory/artifacthub_test.exs:45" classname="Elixir.Zebra.Workers.JobRequestFactory.ArtifacthubTest" name="test .generate_token error communicating with API => returns communication_error" time="0.0047"/><testcase file="test/zebra/workers/job_request_factory/artifacthub_test.exs:36" classname="Elixir.Zebra.Workers.JobRequestFactory.ArtifacthubTest" name="test .generate_token on valid storage ID => returns env var" time="0.0051"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" tests="12" time="0.0705"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:74" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id for debug job => returns hook_id" time="0.0070"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:103" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .find when there is a problem with fetching repo_proxy => returns communication_error" time="0.0051"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:32" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id when project_debug_job => returns nil" time="0.0099"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:66" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id when debugged job is missing for debug job => returns stop_job_processing" time="0.0055"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:38" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id when pipeline_job without build_id => returns stop_job_processing" time="0.0045"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:99" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .find when hook_id is nil => returns nil" time="0.0038"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:45" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id when build is missing for pipeline_job => returns stop_job_processing" time="0.0048"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:131" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .find when everything goes smooth => returns hook" time="0.0059"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:59" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id when debug is missing for debug job => returns stop_job_processing" time="0.0049"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:116" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .find when there is no hook => returns nil" time="0.0057"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:84" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id for debug job of a debug job => returns hook_id" time="0.0080"/><testcase file="test/zebra/workers/job_request_factory/repo_proxy_test.exs:52" classname="Elixir.Zebra.Workers.JobRequestFactory.RepoProxyTest" name="test .extract_hook_id for pipeline_job => returns hook_id" time="0.0053"/></testsuite><testsuite errors="0" failures="12" skipped="0" name="Elixir.Zebra.Apis.InternalTaskApiTest" tests="12" time="0.0874"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/internal_task_api_test.exs:68" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .describe task found => returns serialized task" time="0.0060"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  1) test .describe task found =&gt; returns serialized task (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:68
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: task_id = schedule_task()
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:242: Zebra.Apis.InternalTaskApiTest.schedule_task/1
       test/zebra/apis/internal_task_api_test.exs:69: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:105" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .terminate task found => terminates task" time="0.0056"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  2) test .terminate task found =&gt; terminates task (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:105
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: task_id = schedule_task()
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:242: Zebra.Apis.InternalTaskApiTest.schedule_task/1
       test/zebra/apis/internal_task_api_test.exs:106: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:10" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .schedule scheduling with zero jobs => invalid" time="0.0055"><failure message="Assertion with == failed">  3) test .schedule scheduling with zero jobs =&gt; invalid (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:10
     Assertion with == failed
     code:  assert e == %GRPC.RPCError{message: "A task must have at least one job", status: 3}
     left:  %GRPC.RPCError{message: "Internal Server Error", status: 2}
     right: %GRPC.RPCError{message: "A task must have at least one job", status: 3}
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:14: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:61" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .describe task not found => returns GRPC :not_found" time="0.0081"><failure message="Assertion with == failed">  4) test .describe task not found =&gt; returns GRPC :not_found (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:61
     Assertion with == failed
     code:  assert e.status == GRPC.Status.not_found()
     left:  2
     right: 5
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:65: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:17" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .schedule first time scheduling => created new task" time="0.0087"><failure message="match (=) failed">  5) test .schedule first time scheduling =&gt; created new task (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:17
     match (=) failed
     code:  assert {:ok, task} = Zebra.Models.Task.find_by_request_token(@req_token)
     left:  {:ok, task}
     right: {:error, :not_found}
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:22: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:98" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .terminate task not found => returns GRCP :not_found" time="0.0114"><failure message="Assertion with == failed">  6) test .terminate task not found =&gt; returns GRCP :not_found (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:98
     Assertion with == failed
     code:  assert e.status == GRPC.Status.not_found()
     left:  2
     right: 5
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:102: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:26" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .schedule first time scheduling => returns task_id" time="0.0055"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  7) test .schedule first time scheduling =&gt; returns task_id (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:26
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.schedule(channel(), req)
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:29: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:136" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .terminate repeated calls" time="0.0057"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  8) test .terminate repeated calls (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:136
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: task_id = schedule_task()
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:242: Zebra.Apis.InternalTaskApiTest.schedule_task/1
       test/zebra/apis/internal_task_api_test.exs:137: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:47" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .schedule schedule creates a task with all its jobs" time="0.0057"><failure message="match (=) failed">  9) test .schedule schedule creates a task with all its jobs (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:47
     match (=) failed
     code:  assert {:ok, task} = Zebra.Models.Task.find_by_request_token(@req_token)
     left:  {:ok, task}
     right: {:error, :not_found}
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:52: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:114" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .terminate requests async stop for all jobs" time="0.0057"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 10) test .terminate requests async stop for all jobs (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:114
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: task_id = schedule_task()
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:242: Zebra.Apis.InternalTaskApiTest.schedule_task/1
       test/zebra/apis/internal_task_api_test.exs:115: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:82" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .describe_many tasks found => returns serialized tasks" time="0.0063"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 11) test .describe_many tasks found =&gt; returns serialized tasks (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:82
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: task_id1 = schedule_task(Ecto.UUID.generate())
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:242: Zebra.Apis.InternalTaskApiTest.schedule_task/1
       test/zebra/apis/internal_task_api_test.exs:83: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_task_api_test.exs:35" classname="Elixir.Zebra.Apis.InternalTaskApiTest" name="test .schedule second time scheduling with same token => returns existing task" time="0.0131"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 12) test .schedule second time scheduling with same token =&gt; returns existing task (Zebra.Apis.InternalTaskApiTest)
     test/zebra/apis/internal_task_api_test.exs:35
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply1} = Stub.schedule(channel(), req)
     stacktrace:
       test/zebra/apis/internal_task_api_test.exs:39: (test)
</failure></testcase></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" tests="9" time="0.0393"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:49" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns :ok for valid a1 machines xcode13" time="0.0038"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:85" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns error for unknown types" time="0.0047"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:38" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns :ok for valid a1 machines xcode12" time="0.0046"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:65" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns :ok for valid e1 machines" time="0.0048"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:107" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns error for obsolete os image types xcode11" time="0.0040"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:28" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns error if self-hosted agent type does not exist" time="0.0052"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:96" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns error for obsolete os image types xcode10" time="0.0038"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:57" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns :ok for valid ax1 machines xcode13" time="0.0039"/><testcase file="test/zebra/workers/job_request_factory/machine_test.exs:21" classname="Elixir.Zebra.Workers.JobRequestFactory.MachineTest" name="test it returns :ok if self-hosted agent type exists" time="0.0045"/></testsuite><testsuite errors="0" failures="3" skipped="0" name="Elixir.Zebra.Apis.DeploymentTargetsTest" tests="4" time="0.0280"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/deployment_targets_test.exs:28" classname="Elixir.Zebra.Apis.DeploymentTargetsTest" name="test when job has deployment_target_id then check positive access from gofer" time="0.0060"><failure message="error: key :git_ref_type not found in: %Cachex.ExecutionError{message: &quot;errors were found at the given arguments:\n\n  * 1st argument: not a pid\n&quot;, stack: [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Cachex.Services.Courier, :&quot;-handle_call/3-fun-0-&quot;, 5, [file: 'lib/cachex/services/courier.ex', line: 77]}, {Cachex.Services.Courier, :dispatch, 3, [file: 'lib/cachex/services/courier.ex', line: 44]}, {Cachex, :fetch, 4, [file: 'lib/cachex.ex', line: 693]}, {Zebra.Workers.JobRequestFactory.RepoProxy, :find, 1, [file: 'lib/zebra/workers/job_request_factory/repo_proxy.ex', line: 46]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}">  1) test when job has deployment_target_id then check positive access from gofer (Zebra.Apis.DeploymentTargetsTest)
     test/zebra/apis/deployment_targets_test.exs:28
     ** (KeyError) key :git_ref_type not found in: %Cachex.ExecutionError{message: "errors were found at the given arguments:\n\n  * 1st argument: not a pid\n", stack: [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Cachex.Services.Courier, :"-handle_call/3-fun-0-", 5, [file: 'lib/cachex/services/courier.ex', line: 77]}, {Cachex.Services.Courier, :dispatch, 3, [file: 'lib/cachex/services/courier.ex', line: 44]}, {Cachex, :fetch, 4, [file: 'lib/cachex.ex', line: 693]}, {Zebra.Workers.JobRequestFactory.RepoProxy, :find, 1, [file: 'lib/zebra/workers/job_request_factory/repo_proxy.ex', line: 46]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     code: assert {:ok, true} = Zebra.Apis.DeploymentTargets.can_run?(job, @user_id)
     stacktrace:
       (zebra 0.0.1) lib/zebra/apis/deployment_targets.ex:23: Zebra.Apis.DeploymentTargets.can_run?/2
       test/zebra/apis/deployment_targets_test.exs:47: (test)
</failure></testcase><testcase file="test/zebra/apis/deployment_targets_test.exs:13" classname="Elixir.Zebra.Apis.DeploymentTargetsTest" name="test when job has no deployment_target_id then grant access" time="0.0056"/><testcase file="test/zebra/apis/deployment_targets_test.exs:74" classname="Elixir.Zebra.Apis.DeploymentTargetsTest" name="test when job has deployment_target_id and error occurs then return it" time="0.0079"><failure message="error: key :git_ref_type not found in: %Cachex.ExecutionError{message: &quot;errors were found at the given arguments:\n\n  * 1st argument: not a pid\n&quot;, stack: [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Cachex.Services.Courier, :&quot;-handle_call/3-fun-0-&quot;, 5, [file: 'lib/cachex/services/courier.ex', line: 77]}, {Cachex.Services.Courier, :dispatch, 3, [file: 'lib/cachex/services/courier.ex', line: 44]}, {Cachex, :fetch, 4, [file: 'lib/cachex.ex', line: 693]}, {Zebra.Workers.JobRequestFactory.RepoProxy, :find, 1, [file: 'lib/zebra/workers/job_request_factory/repo_proxy.ex', line: 46]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}">  3) test when job has deployment_target_id and error occurs then return it (Zebra.Apis.DeploymentTargetsTest)
     test/zebra/apis/deployment_targets_test.exs:74
     ** (KeyError) key :git_ref_type not found in: %Cachex.ExecutionError{message: "errors were found at the given arguments:\n\n  * 1st argument: not a pid\n", stack: [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Cachex.Services.Courier, :"-handle_call/3-fun-0-", 5, [file: 'lib/cachex/services/courier.ex', line: 77]}, {Cachex.Services.Courier, :dispatch, 3, [file: 'lib/cachex/services/courier.ex', line: 44]}, {Cachex, :fetch, 4, [file: 'lib/cachex.ex', line: 693]}, {Zebra.Workers.JobRequestFactory.RepoProxy, :find, 1, [file: 'lib/zebra/workers/job_request_factory/repo_proxy.ex', line: 46]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     code: Zebra.Apis.DeploymentTargets.can_run?(job, @user_id)
     stacktrace:
       (zebra 0.0.1) lib/zebra/apis/deployment_targets.ex:23: Zebra.Apis.DeploymentTargets.can_run?/2
       test/zebra/apis/deployment_targets_test.exs:92: (test)
</failure></testcase><testcase file="test/zebra/apis/deployment_targets_test.exs:50" classname="Elixir.Zebra.Apis.DeploymentTargetsTest" name="test when job has deployment_target_id then check negative access from gofer" time="0.0085"><failure message="error: key :git_ref_type not found in: %Cachex.ExecutionError{message: &quot;errors were found at the given arguments:\n\n  * 1st argument: not a pid\n&quot;, stack: [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Cachex.Services.Courier, :&quot;-handle_call/3-fun-0-&quot;, 5, [file: 'lib/cachex/services/courier.ex', line: 77]}, {Cachex.Services.Courier, :dispatch, 3, [file: 'lib/cachex/services/courier.ex', line: 44]}, {Cachex, :fetch, 4, [file: 'lib/cachex.ex', line: 693]}, {Zebra.Workers.JobRequestFactory.RepoProxy, :find, 1, [file: 'lib/zebra/workers/job_request_factory/repo_proxy.ex', line: 46]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}">  4) test when job has deployment_target_id then check negative access from gofer (Zebra.Apis.DeploymentTargetsTest)
     test/zebra/apis/deployment_targets_test.exs:50
     ** (KeyError) key :git_ref_type not found in: %Cachex.ExecutionError{message: "errors were found at the given arguments:\n\n  * 1st argument: not a pid\n", stack: [{:erlang, :process_info, [nil, :message_queue_len], [error_info: %{module: :erl_erts_errors}]}, {Process, :info, 2, [file: 'lib/process.ex', line: 773]}, {Watchman.Server, :buffer_size, 0, [file: 'lib/watchman/server.ex', line: 53]}, {Watchman.Server, :submit, 3, [file: 'lib/watchman/server.ex', line: 61]}, {Watchman, :benchmark, 2, [file: 'lib/watchman.ex', line: 37]}, {Cachex.Services.Courier, :"-handle_call/3-fun-0-", 5, [file: 'lib/cachex/services/courier.ex', line: 77]}, {Cachex.Services.Courier, :dispatch, 3, [file: 'lib/cachex/services/courier.ex', line: 44]}, {Cachex, :fetch, 4, [file: 'lib/cachex.ex', line: 693]}, {Zebra.Workers.JobRequestFactory.RepoProxy, :find, 1, [file: 'lib/zebra/workers/job_request_factory/repo_proxy.ex', line: 46]}, {Task.Supervised, :invoke_mfa, 2, [file: 'lib/task/supervised.ex', line: 89]}, {Task.Supervised, :reply, 4, [file: 'lib/task/supervised.ex', line: 34]}, {:proc_lib, :init_p_do_apply, 3, [file: 'proc_lib.erl', line: 226]}]}
     code: Zebra.Apis.DeploymentTargets.can_run?(job, @user_id)
     stacktrace:
       (zebra 0.0.1) lib/zebra/apis/deployment_targets.ex:23: Zebra.Apis.DeploymentTargets.can_run?/2
       test/zebra/apis/deployment_targets_test.exs:71: (test)
</failure></testcase></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobRequestFactory.OrganizationTest" tests="3" time="0.0151"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_request_factory/organization_test.exs:9" classname="Elixir.Zebra.Workers.JobRequestFactory.OrganizationTest" name="test .find when describe org request succeeds => it constructs the org url variable" time="0.0043"/><testcase file="test/zebra/workers/job_request_factory/organization_test.exs:39" classname="Elixir.Zebra.Workers.JobRequestFactory.OrganizationTest" name="test .find when describe org is not found => it returns an error tuple" time="0.0046"/><testcase file="test/zebra/workers/job_request_factory/organization_test.exs:30" classname="Elixir.Zebra.Workers.JobRequestFactory.OrganizationTest" name="test .find when grpc communication fails => it returns an error tuple" time="0.0063"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.WaitingJobTerminatorTest" tests="2" time="0.0877"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/waiting_job_terminator_test.exs:41" classname="Elixir.Zebra.Workers.WaitingJobTerminatorTest" name="test jobs in scheduled state that exceed max scheduled time are terminated" time="0.0116"/><testcase file="test/zebra/workers/waiting_job_terminator_test.exs:4" classname="Elixir.Zebra.Workers.WaitingJobTerminatorTest" name="test jobs in waiting-for-agent state that exceed max scheduled time are terminated" time="0.0761"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.ParallelTest" tests="6" time="2.3598"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/parallel_test.exs:5" classname="Elixir.Zebra.ParallelTest" name="test .in_batches it processes all entries" time="0.0000"/><testcase file="test/zebra/parallel_test.exs:37" classname="Elixir.Zebra.ParallelTest" name="test stream/3 handles timeouts gracefully" time="2.1048"/><testcase file="test/zebra/parallel_test.exs:27" classname="Elixir.Zebra.ParallelTest" name="test stream/3 it processes all entries" time="0.0001"/><testcase file="test/zebra/parallel_test.exs:68" classname="Elixir.Zebra.ParallelTest" name="test stream/3 handles passing metadata to logger" time="0.0001"/><testcase file="test/zebra/parallel_test.exs:57" classname="Elixir.Zebra.ParallelTest" name="test stream/3 handles custom timeout" time="0.2547"/><testcase file="test/zebra/parallel_test.exs:15" classname="Elixir.Zebra.ParallelTest" name="test .in_batches it halts" time="0.0000"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.FeatureProviderInvalidatorWorkerTest" tests="4" time="0.0040"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/feature_provider_invalidator_worker_test.exs:51" classname="Elixir.Zebra.Workers.FeatureProviderInvalidatorWorkerTest" name="test .machines_changed when the organization machine state changes, organization machine caches are invalidated" time="0.0003"/><testcase file="test/zebra/workers/feature_provider_invalidator_worker_test.exs:24" classname="Elixir.Zebra.Workers.FeatureProviderInvalidatorWorkerTest" name="test .machines_changed when the machine state changes, machine caches are invalidated" time="0.0010"/><testcase file="test/zebra/workers/feature_provider_invalidator_worker_test.exs:105" classname="Elixir.Zebra.Workers.FeatureProviderInvalidatorWorkerTest" name="test .machines_changed when the organization feature state changes, organization feature caches are invalidated" time="0.0003"/><testcase file="test/zebra/workers/feature_provider_invalidator_worker_test.exs:78" classname="Elixir.Zebra.Workers.FeatureProviderInvalidatorWorkerTest" name="test .machines_changed when the feature state changes, feature caches are invalidated" time="0.0024"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.MachinesTest" tests="12" time="0.0491"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/machines_test.exs:50" classname="Elixir.Zebra.MachinesTest" name="test mac_machine_types returns list of all mac machine types" time="0.0039"/><testcase file="test/zebra/machines_test.exs:84" classname="Elixir.Zebra.MachinesTest" name="test registered? returns false for not registered machines" time="0.0038"/><testcase file="test/zebra/machines_test.exs:5" classname="Elixir.Zebra.MachinesTest" name="test mac? returns true for mac machine types" time="0.0040"/><testcase file="test/zebra/machines_test.exs:34" classname="Elixir.Zebra.MachinesTest" name="test linux_machine_types returns list of all linux machine types" time="0.0038"/><testcase file="test/zebra/machines_test.exs:9" classname="Elixir.Zebra.MachinesTest" name="test mac? returns false for non-mac machine types" time="0.0038"/><testcase file="test/zebra/machines_test.exs:78" classname="Elixir.Zebra.MachinesTest" name="test registered? returns true for registered machines" time="0.0042"/><testcase file="test/zebra/machines_test.exs:15" classname="Elixir.Zebra.MachinesTest" name="test linux? returns true for linux machine types" time="0.0038"/><testcase file="test/zebra/machines_test.exs:102" classname="Elixir.Zebra.MachinesTest" name="test default_os_image unknown machine_type => returns error" time="0.0041"/><testcase file="test/zebra/machines_test.exs:24" classname="Elixir.Zebra.MachinesTest" name="test os_images returns list of all os images" time="0.0042"/><testcase file="test/zebra/machines_test.exs:94" classname="Elixir.Zebra.MachinesTest" name="test default_os_image known machine_type => returns the default image" time="0.0043"/><testcase file="test/zebra/machines_test.exs:58" classname="Elixir.Zebra.MachinesTest" name="test machine_types returns list of all machine types" time="0.0052"/><testcase file="test/zebra/machines_test.exs:19" classname="Elixir.Zebra.MachinesTest" name="test linux? returns false for non-linux machine types" time="0.0040"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Models.JobStopRequestTest" tests="8" time="1.0433"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/models/job_stop_request_test.exs:22" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .create it sets created_at and updated_at" time="0.0074"/><testcase file="test/zebra/models/job_stop_request_test.exs:76" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .update it updates updated_at" time="1.0061"/><testcase file="test/zebra/models/job_stop_request_test.exs:16" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .find_by_job_id when the record exists => returns an error" time="0.0043"/><testcase file="test/zebra/models/job_stop_request_test.exs:50" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .bulk_create when there are no conflicting recorgs => ignores conflicts" time="0.0057"/><testcase file="test/zebra/models/job_stop_request_test.exs:101" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .complete it sets the result" time="0.0050"/><testcase file="test/zebra/models/job_stop_request_test.exs:10" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .find_by_job_id when the record exists => returns the record" time="0.0048"/><testcase file="test/zebra/models/job_stop_request_test.exs:90" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .update it updates the fields" time="0.0048"/><testcase file="test/zebra/models/job_stop_request_test.exs:33" classname="Elixir.Zebra.Models.JobStopRequestTest" name="test .bulk_create when there are no conflicting recorgs => creates all the entries" time="0.0051"/></testsuite><testsuite errors="0" failures="32" skipped="0" name="Elixir.Zebra.Api.InternalJobApiTest" tests="35" time="8.5418"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/apis/internal_job_api_test.exs:924" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .can_debug when the job is not present => returns :not found" time="0.0050"/><testcase file="test/zebra/apis/internal_job_api_test.exs:992" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .can_attach when the job is not present => returns :not found" time="0.0054"/><testcase file="test/zebra/apis/internal_job_api_test.exs:514" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .describe self hosted job is found" time="0.0086"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  3) test .describe self hosted job is found (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:514
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} = Stub.describe(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:530: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:249" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list returns empty list if job for machine type does not exist" time="0.0079"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  4) test .list returns empty list if job for machine type does not exist (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:249
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:266: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:813" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .stop when the job is present => requests an async stop" time="0.0076"><failure message="match (=) failed">  5) test .stop when the job is present =&gt; requests an async stop (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:813
     match (=) failed
     code:  assert {:ok, %Response{status: %{code: 0}}} = channel |&gt; Stub.stop(request)
     left:  {:ok, %InternalApi.ServerFarm.Job.StopResponse{status: %{code: 0}}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:828: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:906" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .can_debug when the job is present => returns proper status" time="0.0396"><failure message="match (=) failed">  6) test .can_debug when the job is present =&gt; returns proper status (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:906
     match (=) failed
     code:  assert {:ok, %Response{allowed: true}} = Stub.can_debug(channel, request)
     left:  {:ok, %InternalApi.ServerFarm.Job.CanDebugResponse{allowed: true}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:920: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:780" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .total_execution_time when the org_id exists => calulate total time of all jobs" time="0.0108"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  7) test .total_execution_time when the org_id exists =&gt; calulate total time of all jobs (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:780
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.total_execution_time(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:805: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:587" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list_debug_sessions when page_size is too high => it returns error" time="0.0050"><failure message="match (=) failed">  8) test .list_debug_sessions when page_size is too high =&gt; it returns error (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:587
     match (=) failed
     code:  assert {:ok, res} = Stub.list_debug_sessions(channel, request)
     left:  {:ok, res}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:592: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:221" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list returns only jobs in created_at range" time="0.0087"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}">  9) test .list returns only jobs in created_at range (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:221
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:243: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:69" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list pagination" time="0.0099"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 10) test .list pagination (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:69
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req1)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:87: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:566" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .describe job not found" time="0.0060"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 11) test .describe job not found (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:566
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} = Stub.describe(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:574: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:151" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list return only debug jobs and filter by org_id" time="2.0331"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 12) test .list return only debug jobs and filter by org_id (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:151
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:196: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:836" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .stop idempotent requests" time="0.0077"><failure message="match (=) failed"> 13) test .stop idempotent requests (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:836
     match (=) failed
     code:  assert {:ok, %Response{status: %{code: 0}}} = channel |&gt; Stub.stop(request)
     left:  {:ok, %InternalApi.ServerFarm.Job.StopResponse{status: %{code: 0}}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:851: anonymous fn/3 in Zebra.Api.InternalJobApiTest."test .stop idempotent requests"/1
       (elixir 1.13.4) lib/enum.ex:942: anonymous fn/3 in Enum.each/2
       (elixir 1.13.4) lib/enum.ex:4136: Enum.reduce_range/5
       (elixir 1.13.4) lib/enum.ex:2400: Enum.each/2
       test/zebra/apis/internal_job_api_test.exs:850: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:963" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .can_attach when deployment target prevents attaching to job => returns proper status" time="0.0644"><failure message="match (=) failed"> 14) test .can_attach when deployment target prevents attaching to job =&gt; returns proper status (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:963
     match (=) failed
     code:  assert {:ok, %Response{allowed: false, message: "You are not allowed to access Deployment Target"}} =
              Stub.can_attach(channel, request)
     left:  {:ok,
             %InternalApi.ServerFarm.Job.CanAttachResponse{
               allowed: false,
               message: "You are not allowed to access Deployment Target"
             }}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:984: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:859" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .stop when the job is not found => returns not found" time="0.0127"><failure message="match (=) failed"> 15) test .stop when the job is not found =&gt; returns not found (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:859
     match (=) failed
     code:  assert {:ok, %Response{status: %{code: 1, message: message}}} = channel |&gt; Stub.stop(request)
     left:  {:ok, %InternalApi.ServerFarm.Job.StopResponse{status: %{code: 1, message: message}}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:868: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:105" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list return only jobs that belong to one of given pipelines" time="2.0305"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 16) test .list return only jobs that belong to one of given pipelines (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:105
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:130: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:374" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .count_by_state only returns counts for requested states" time="0.0075"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 17) test .count_by_state only returns counts for requested states (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:374
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} =
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:382: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:1086" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .create when all params are ok => return job" time="0.0059"><failure message="match (=) failed"> 18) test .create when all params are ok =&gt; return job (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:1086
     match (=) failed
     code:  assert {:ok, reply} = Stub.create(channel, request)
     left:  {:ok, reply}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:1129: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:621" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list_debug_sessions pagination" time="0.0140"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 19) test .list_debug_sessions pagination (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:621
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list_debug_sessions(channel, req1)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:638: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:272" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list returns only jobs for specified machine_types" time="0.0082"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 20) test .list returns only jobs for specified machine_types (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:272
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:289: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:23" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list when every parameter is correct => it returns list of jobs" time="0.0069"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 21) test .list when every parameter is correct =&gt; it returns list of jobs (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:23
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, request)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:33: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:891" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .get_agent_payload when the job is not present => returns :not found" time="0.0072"/><testcase file="test/zebra/apis/internal_job_api_test.exs:468" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .describe job is found" time="0.0111"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 23) test .describe job is found (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:468
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} = Stub.describe(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:478: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:325" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .count returns count of jobs" time="0.0210"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 24) test .count returns count of jobs (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:325
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} = Stub.count(channel, req1)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:345: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:708" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list_debug_sessions return only debug jobs and filter by org_id" time="2.0228"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 25) test .list_debug_sessions return only debug jobs and filter by org_id (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:708
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:753: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:1008" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .create when params are invalid => return error message" time="0.0100"><failure message="match (=) failed"> 26) test .create when params are invalid =&gt; return error message (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:1008
     match (=) failed
     code:  assert {:ok, reply} = Stub.create(channel, request)
     left:  {:ok, reply}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:1052: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:404" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .count_by_state finished jobs are not counted" time="0.0093"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 27) test .count_by_state finished jobs are not counted (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:404
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} =
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:412: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:597" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list_debug_sessions when every parameter is correct => it returns list of jobs" time="0.0176"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 28) test .list_debug_sessions when every parameter is correct =&gt; it returns list of jobs (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:597
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list_debug_sessions(channel, request)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:614: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:298" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list returns jobs for all machine types if no machine types are specified" time="0.0110"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 29) test .list returns jobs for all machine types if no machine types are specified (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:298
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:311: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:438" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .count_by_state requested state count is returned even if no jobs exist for that state" time="0.0082"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 30) test .count_by_state requested state count is returned even if no jobs exist for that state (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:438
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} =
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:444: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:941" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .can_attach when the job is present => returns proper status" time="0.0668"><failure message="match (=) failed"> 31) test .can_attach when the job is present =&gt; returns proper status (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:941
     match (=) failed
     code:  assert {:ok, %Response{allowed: true}} = Stub.can_attach(channel, request)
     left:  {:ok, %InternalApi.ServerFarm.Job.CanAttachResponse{allowed: true}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:959: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:876" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .get_agent_payload when the job is present => returns payload" time="0.0090"><failure message="match (=) failed"> 32) test .get_agent_payload when the job is present =&gt; returns payload (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:876
     match (=) failed
     code:  assert {:ok, %Response{payload: payload}} = Stub.get_agent_payload(channel, request)
     left:  {:ok, %InternalApi.ServerFarm.Job.GetAgentPayloadResponse{payload: payload}}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:887: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:10" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list when page_size is too high => it returns error" time="0.0137"><failure message="match (=) failed"> 33) test .list when page_size is too high =&gt; it returns error (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:10
     match (=) failed
     code:  assert {:ok, res} = Stub.list(channel, request)
     left:  {:ok, res}
     right: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:18: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:662" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .list_debug_sessions return only jobs that belong to one of given pipelines" time="2.0199"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 34) test .list_debug_sessions return only jobs that belong to one of given pipelines (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:662
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, reply} = Stub.list(channel, req)
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:687: (test)
</failure></testcase><testcase file="test/zebra/apis/internal_job_api_test.exs:358" classname="Elixir.Zebra.Api.InternalJobApiTest" name="test .count_by_state returns empty if no states specified" time="0.0084"><failure message="error: no match of right hand side value: {:error, %GRPC.RPCError{message: &quot;Internal Server Error&quot;, status: 2}}"> 35) test .count_by_state returns empty if no states specified (Zebra.Api.InternalJobApiTest)
     test/zebra/apis/internal_job_api_test.exs:358
     ** (MatchError) no match of right hand side value: {:error, %GRPC.RPCError{message: "Internal Server Error", status: 2}}
     code: {:ok, res} =
     stacktrace:
       test/zebra/apis/internal_job_api_test.exs:362: (test)
</failure></testcase></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" tests="7" time="0.0415"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/job_finished_callback_worker_test.exs:25" classname="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" name="test .handle_message when the payload result is nil => saves false" time="0.0062"/><testcase file="test/zebra/workers/job_finished_callback_worker_test.exs:73" classname="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" name="test .handle_message when the job is failed => it doesn't raise an error" time="0.0051"/><testcase file="test/zebra/workers/job_finished_callback_worker_test.exs:8" classname="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" name="test .handle_message when the job is started => handles a started callback message" time="0.0063"/><testcase file="test/zebra/workers/job_finished_callback_worker_test.exs:58" classname="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" name="test .handle_message when the job is passed => it doesn't raise an error" time="0.0055"/><testcase file="test/zebra/workers/job_finished_callback_worker_test.exs:102" classname="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" name="test .handle_message when job is not found => raise error" time="0.0045"/><testcase file="test/zebra/workers/job_finished_callback_worker_test.exs:88" classname="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" name="test .handle_message when the job is not started => process message" time="0.0064"/><testcase file="test/zebra/workers/job_finished_callback_worker_test.exs:43" classname="Elixir.Zebra.Workers.JobFinishedCallbackWorkerTest" name="test .handle_message when the job is stopped => it doesn't raise an error and publishes a finished message" time="0.0076"/></testsuite><testsuite errors="0" failures="0" skipped="0" name="Elixir.Zebra.Workers.TaskFinisherTest" tests="8" time="0.0632"><properties><property name="date" value="2025-12-05T10:33:43.444710Z"/><property name="seed" value="423031"/></properties><testcase file="test/zebra/workers/task_finisher_test.exs:61" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .calculate_task_result when any of the jobs are stopped => result is stopped" time="0.0047"/><testcase file="test/zebra/workers/task_finisher_test.exs:82" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .calculate_task_result when fail_fast:stop is active and jobs are stopped due to failure => result is failed" time="0.0045"/><testcase file="test/zebra/workers/task_finisher_test.exs:31" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .process it calculates the task result and saves into the db" time="0.0079"/><testcase file="test/zebra/workers/task_finisher_test.exs:75" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .calculate_task_result when all of the jobs are passed => result is passed" time="0.0071"/><testcase file="test/zebra/workers/task_finisher_test.exs:96" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .calculate_task_result when fail_fast:cancel is active and jobs are stopped due to failure => result is stopped" time="0.0051"/><testcase file="test/zebra/workers/task_finisher_test.exs:7" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .tick it calculates the task result for all tasks" time="0.0221"/><testcase file="test/zebra/workers/task_finisher_test.exs:89" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .calculate_task_result when fail_fast:stop is active but no jobs failed => result is stopped" time="0.0055"/><testcase file="test/zebra/workers/task_finisher_test.exs:68" classname="Elixir.Zebra.Workers.TaskFinisherTest" name="test .calculate_task_result when any of the jobs are failed => result is failed" time="0.0064"/></testsuite></testsuites>