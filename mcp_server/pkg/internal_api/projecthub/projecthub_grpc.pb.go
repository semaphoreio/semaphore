// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.20.0
// source: projecthub.proto

package projecthub

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ProjectService_List_FullMethodName                = "/InternalApi.Projecthub.ProjectService/List"
	ProjectService_ListKeyset_FullMethodName          = "/InternalApi.Projecthub.ProjectService/ListKeyset"
	ProjectService_Describe_FullMethodName            = "/InternalApi.Projecthub.ProjectService/Describe"
	ProjectService_DescribeMany_FullMethodName        = "/InternalApi.Projecthub.ProjectService/DescribeMany"
	ProjectService_Create_FullMethodName              = "/InternalApi.Projecthub.ProjectService/Create"
	ProjectService_Update_FullMethodName              = "/InternalApi.Projecthub.ProjectService/Update"
	ProjectService_Destroy_FullMethodName             = "/InternalApi.Projecthub.ProjectService/Destroy"
	ProjectService_Users_FullMethodName               = "/InternalApi.Projecthub.ProjectService/Users"
	ProjectService_CheckDeployKey_FullMethodName      = "/InternalApi.Projecthub.ProjectService/CheckDeployKey"
	ProjectService_RegenerateDeployKey_FullMethodName = "/InternalApi.Projecthub.ProjectService/RegenerateDeployKey"
	ProjectService_CheckWebhook_FullMethodName        = "/InternalApi.Projecthub.ProjectService/CheckWebhook"
	ProjectService_RegenerateWebhook_FullMethodName   = "/InternalApi.Projecthub.ProjectService/RegenerateWebhook"
	ProjectService_ChangeProjectOwner_FullMethodName  = "/InternalApi.Projecthub.ProjectService/ChangeProjectOwner"
	ProjectService_ForkAndCreate_FullMethodName       = "/InternalApi.Projecthub.ProjectService/ForkAndCreate"
	ProjectService_GithubAppSwitch_FullMethodName     = "/InternalApi.Projecthub.ProjectService/GithubAppSwitch"
	ProjectService_FinishOnboarding_FullMethodName    = "/InternalApi.Projecthub.ProjectService/FinishOnboarding"
)

// ProjectServiceClient is the client API for ProjectService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectServiceClient interface {
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	ListKeyset(ctx context.Context, in *ListKeysetRequest, opts ...grpc.CallOption) (*ListKeysetResponse, error)
	Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error)
	DescribeMany(ctx context.Context, in *DescribeManyRequest, opts ...grpc.CallOption) (*DescribeManyResponse, error)
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyResponse, error)
	// Operation is called to list Semaphore users on the project.
	// Operation is synchronous.
	Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// Operation is called to check the status of a deploy key.
	// Operation is synchronous.
	CheckDeployKey(ctx context.Context, in *CheckDeployKeyRequest, opts ...grpc.CallOption) (*CheckDeployKeyResponse, error)
	// Operation is called to regenerate a deploy key.
	// Operation is synchronous.
	RegenerateDeployKey(ctx context.Context, in *RegenerateDeployKeyRequest, opts ...grpc.CallOption) (*RegenerateDeployKeyResponse, error)
	// Operation is called to check the status of a webhook.
	// Operation is synchronous.
	CheckWebhook(ctx context.Context, in *CheckWebhookRequest, opts ...grpc.CallOption) (*CheckWebhookResponse, error)
	// Operation is called to regenerate a webhook.
	// Operation is synchronous.
	RegenerateWebhook(ctx context.Context, in *RegenerateWebhookRequest, opts ...grpc.CallOption) (*RegenerateWebhookResponse, error)
	// Operation is called to change a project owner within the same organization.
	// Operation is synchronous.
	ChangeProjectOwner(ctx context.Context, in *ChangeProjectOwnerRequest, opts ...grpc.CallOption) (*ChangeProjectOwnerResponse, error)
	// Operation is called to fork and then add repository
	// Operation is synchronous.
	ForkAndCreate(ctx context.Context, in *ForkAndCreateRequest, opts ...grpc.CallOption) (*ForkAndCreateResponse, error)
	// Operation is called to switch project from github_oauth_token to github_app integration
	// Operation is synchronous.
	GithubAppSwitch(ctx context.Context, in *GithubAppSwitchRequest, opts ...grpc.CallOption) (*GithubAppSwitchResponse, error)
	// Operation is called to transition project from onboarding to ready state.
	// Operation is synchronous.
	FinishOnboarding(ctx context.Context, in *FinishOnboardingRequest, opts ...grpc.CallOption) (*FinishOnboardingResponse, error)
}

type projectServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectServiceClient(cc grpc.ClientConnInterface) ProjectServiceClient {
	return &projectServiceClient{cc}
}

func (c *projectServiceClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, ProjectService_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) ListKeyset(ctx context.Context, in *ListKeysetRequest, opts ...grpc.CallOption) (*ListKeysetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeysetResponse)
	err := c.cc.Invoke(ctx, ProjectService_ListKeyset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Describe(ctx context.Context, in *DescribeRequest, opts ...grpc.CallOption) (*DescribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeResponse)
	err := c.cc.Invoke(ctx, ProjectService_Describe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) DescribeMany(ctx context.Context, in *DescribeManyRequest, opts ...grpc.CallOption) (*DescribeManyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DescribeManyResponse)
	err := c.cc.Invoke(ctx, ProjectService_DescribeMany_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, ProjectService_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, ProjectService_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroyResponse)
	err := c.cc.Invoke(ctx, ProjectService_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) Users(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UsersResponse)
	err := c.cc.Invoke(ctx, ProjectService_Users_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) CheckDeployKey(ctx context.Context, in *CheckDeployKeyRequest, opts ...grpc.CallOption) (*CheckDeployKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckDeployKeyResponse)
	err := c.cc.Invoke(ctx, ProjectService_CheckDeployKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) RegenerateDeployKey(ctx context.Context, in *RegenerateDeployKeyRequest, opts ...grpc.CallOption) (*RegenerateDeployKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegenerateDeployKeyResponse)
	err := c.cc.Invoke(ctx, ProjectService_RegenerateDeployKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) CheckWebhook(ctx context.Context, in *CheckWebhookRequest, opts ...grpc.CallOption) (*CheckWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckWebhookResponse)
	err := c.cc.Invoke(ctx, ProjectService_CheckWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) RegenerateWebhook(ctx context.Context, in *RegenerateWebhookRequest, opts ...grpc.CallOption) (*RegenerateWebhookResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegenerateWebhookResponse)
	err := c.cc.Invoke(ctx, ProjectService_RegenerateWebhook_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) ChangeProjectOwner(ctx context.Context, in *ChangeProjectOwnerRequest, opts ...grpc.CallOption) (*ChangeProjectOwnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeProjectOwnerResponse)
	err := c.cc.Invoke(ctx, ProjectService_ChangeProjectOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) ForkAndCreate(ctx context.Context, in *ForkAndCreateRequest, opts ...grpc.CallOption) (*ForkAndCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForkAndCreateResponse)
	err := c.cc.Invoke(ctx, ProjectService_ForkAndCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) GithubAppSwitch(ctx context.Context, in *GithubAppSwitchRequest, opts ...grpc.CallOption) (*GithubAppSwitchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GithubAppSwitchResponse)
	err := c.cc.Invoke(ctx, ProjectService_GithubAppSwitch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectServiceClient) FinishOnboarding(ctx context.Context, in *FinishOnboardingRequest, opts ...grpc.CallOption) (*FinishOnboardingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinishOnboardingResponse)
	err := c.cc.Invoke(ctx, ProjectService_FinishOnboarding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectServiceServer is the server API for ProjectService service.
// All implementations should embed UnimplementedProjectServiceServer
// for forward compatibility.
type ProjectServiceServer interface {
	List(context.Context, *ListRequest) (*ListResponse, error)
	ListKeyset(context.Context, *ListKeysetRequest) (*ListKeysetResponse, error)
	Describe(context.Context, *DescribeRequest) (*DescribeResponse, error)
	DescribeMany(context.Context, *DescribeManyRequest) (*DescribeManyResponse, error)
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
	Update(context.Context, *UpdateRequest) (*UpdateResponse, error)
	Destroy(context.Context, *DestroyRequest) (*DestroyResponse, error)
	// Operation is called to list Semaphore users on the project.
	// Operation is synchronous.
	Users(context.Context, *UsersRequest) (*UsersResponse, error)
	// Operation is called to check the status of a deploy key.
	// Operation is synchronous.
	CheckDeployKey(context.Context, *CheckDeployKeyRequest) (*CheckDeployKeyResponse, error)
	// Operation is called to regenerate a deploy key.
	// Operation is synchronous.
	RegenerateDeployKey(context.Context, *RegenerateDeployKeyRequest) (*RegenerateDeployKeyResponse, error)
	// Operation is called to check the status of a webhook.
	// Operation is synchronous.
	CheckWebhook(context.Context, *CheckWebhookRequest) (*CheckWebhookResponse, error)
	// Operation is called to regenerate a webhook.
	// Operation is synchronous.
	RegenerateWebhook(context.Context, *RegenerateWebhookRequest) (*RegenerateWebhookResponse, error)
	// Operation is called to change a project owner within the same organization.
	// Operation is synchronous.
	ChangeProjectOwner(context.Context, *ChangeProjectOwnerRequest) (*ChangeProjectOwnerResponse, error)
	// Operation is called to fork and then add repository
	// Operation is synchronous.
	ForkAndCreate(context.Context, *ForkAndCreateRequest) (*ForkAndCreateResponse, error)
	// Operation is called to switch project from github_oauth_token to github_app integration
	// Operation is synchronous.
	GithubAppSwitch(context.Context, *GithubAppSwitchRequest) (*GithubAppSwitchResponse, error)
	// Operation is called to transition project from onboarding to ready state.
	// Operation is synchronous.
	FinishOnboarding(context.Context, *FinishOnboardingRequest) (*FinishOnboardingResponse, error)
}

// UnimplementedProjectServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProjectServiceServer struct{}

func (UnimplementedProjectServiceServer) List(context.Context, *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedProjectServiceServer) ListKeyset(context.Context, *ListKeysetRequest) (*ListKeysetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKeyset not implemented")
}
func (UnimplementedProjectServiceServer) Describe(context.Context, *DescribeRequest) (*DescribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Describe not implemented")
}
func (UnimplementedProjectServiceServer) DescribeMany(context.Context, *DescribeManyRequest) (*DescribeManyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeMany not implemented")
}
func (UnimplementedProjectServiceServer) Create(context.Context, *CreateRequest) (*CreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedProjectServiceServer) Update(context.Context, *UpdateRequest) (*UpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedProjectServiceServer) Destroy(context.Context, *DestroyRequest) (*DestroyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedProjectServiceServer) Users(context.Context, *UsersRequest) (*UsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Users not implemented")
}
func (UnimplementedProjectServiceServer) CheckDeployKey(context.Context, *CheckDeployKeyRequest) (*CheckDeployKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckDeployKey not implemented")
}
func (UnimplementedProjectServiceServer) RegenerateDeployKey(context.Context, *RegenerateDeployKeyRequest) (*RegenerateDeployKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegenerateDeployKey not implemented")
}
func (UnimplementedProjectServiceServer) CheckWebhook(context.Context, *CheckWebhookRequest) (*CheckWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckWebhook not implemented")
}
func (UnimplementedProjectServiceServer) RegenerateWebhook(context.Context, *RegenerateWebhookRequest) (*RegenerateWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegenerateWebhook not implemented")
}
func (UnimplementedProjectServiceServer) ChangeProjectOwner(context.Context, *ChangeProjectOwnerRequest) (*ChangeProjectOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeProjectOwner not implemented")
}
func (UnimplementedProjectServiceServer) ForkAndCreate(context.Context, *ForkAndCreateRequest) (*ForkAndCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForkAndCreate not implemented")
}
func (UnimplementedProjectServiceServer) GithubAppSwitch(context.Context, *GithubAppSwitchRequest) (*GithubAppSwitchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GithubAppSwitch not implemented")
}
func (UnimplementedProjectServiceServer) FinishOnboarding(context.Context, *FinishOnboardingRequest) (*FinishOnboardingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishOnboarding not implemented")
}
func (UnimplementedProjectServiceServer) testEmbeddedByValue() {}

// UnsafeProjectServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectServiceServer will
// result in compilation errors.
type UnsafeProjectServiceServer interface {
	mustEmbedUnimplementedProjectServiceServer()
}

func RegisterProjectServiceServer(s grpc.ServiceRegistrar, srv ProjectServiceServer) {
	// If the following call pancis, it indicates UnimplementedProjectServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProjectService_ServiceDesc, srv)
}

func _ProjectService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_ListKeyset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).ListKeyset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_ListKeyset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).ListKeyset(ctx, req.(*ListKeysetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_Describe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Describe(ctx, req.(*DescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_DescribeMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).DescribeMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_DescribeMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).DescribeMany(ctx, req.(*DescribeManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Destroy(ctx, req.(*DestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_Users_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).Users(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_Users_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).Users(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_CheckDeployKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckDeployKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).CheckDeployKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_CheckDeployKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).CheckDeployKey(ctx, req.(*CheckDeployKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_RegenerateDeployKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegenerateDeployKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).RegenerateDeployKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_RegenerateDeployKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).RegenerateDeployKey(ctx, req.(*RegenerateDeployKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_CheckWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).CheckWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_CheckWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).CheckWebhook(ctx, req.(*CheckWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_RegenerateWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegenerateWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).RegenerateWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_RegenerateWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).RegenerateWebhook(ctx, req.(*RegenerateWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_ChangeProjectOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeProjectOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).ChangeProjectOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_ChangeProjectOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).ChangeProjectOwner(ctx, req.(*ChangeProjectOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_ForkAndCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForkAndCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).ForkAndCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_ForkAndCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).ForkAndCreate(ctx, req.(*ForkAndCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_GithubAppSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GithubAppSwitchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).GithubAppSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_GithubAppSwitch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).GithubAppSwitch(ctx, req.(*GithubAppSwitchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectService_FinishOnboarding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishOnboardingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectServiceServer).FinishOnboarding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectService_FinishOnboarding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectServiceServer).FinishOnboarding(ctx, req.(*FinishOnboardingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectService_ServiceDesc is the grpc.ServiceDesc for ProjectService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "InternalApi.Projecthub.ProjectService",
	HandlerType: (*ProjectServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ProjectService_List_Handler,
		},
		{
			MethodName: "ListKeyset",
			Handler:    _ProjectService_ListKeyset_Handler,
		},
		{
			MethodName: "Describe",
			Handler:    _ProjectService_Describe_Handler,
		},
		{
			MethodName: "DescribeMany",
			Handler:    _ProjectService_DescribeMany_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _ProjectService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ProjectService_Update_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _ProjectService_Destroy_Handler,
		},
		{
			MethodName: "Users",
			Handler:    _ProjectService_Users_Handler,
		},
		{
			MethodName: "CheckDeployKey",
			Handler:    _ProjectService_CheckDeployKey_Handler,
		},
		{
			MethodName: "RegenerateDeployKey",
			Handler:    _ProjectService_RegenerateDeployKey_Handler,
		},
		{
			MethodName: "CheckWebhook",
			Handler:    _ProjectService_CheckWebhook_Handler,
		},
		{
			MethodName: "RegenerateWebhook",
			Handler:    _ProjectService_RegenerateWebhook_Handler,
		},
		{
			MethodName: "ChangeProjectOwner",
			Handler:    _ProjectService_ChangeProjectOwner_Handler,
		},
		{
			MethodName: "ForkAndCreate",
			Handler:    _ProjectService_ForkAndCreate_Handler,
		},
		{
			MethodName: "GithubAppSwitch",
			Handler:    _ProjectService_GithubAppSwitch_Handler,
		},
		{
			MethodName: "FinishOnboarding",
			Handler:    _ProjectService_FinishOnboarding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "projecthub.proto",
}
